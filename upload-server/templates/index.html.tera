{% import "macros" as m %}

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="/chota.min.css">
    <style>
      body {
        background-color: #A0826D;
        margin: 0;
        padding-bottom: 60px; /* Space for status bar. */
      }
      .container {
        max-width: 1400px;
        margin: 0 auto;
        padding: 20px 10px;
      }

      /* View container management. */
      .view-container {
        display: none;
        opacity: 0;
        transition: opacity 0.25s ease-in-out;
      }
      .view-container.active {
        display: block;
        opacity: 1;
      }

      /* Gallery thumbnails. */
      .thumbnails {
        display: flex;
        flex-wrap: wrap;
        gap: 15px;
      }
      .thumbnail-item {
        text-align: center;
        cursor: pointer;
      }
      .thumbnail-item img {
        height: 100px;
        border: 4px solid #555;
        padding: 1px;
        display: block;
        transition: border-color 0.2s;
      }
      .thumbnail-item img:hover {
        border-color: #B8956A;
      }
      .thumbnail-item .thumb-filename {
        font-size: 0.75em;
        color: #C9DBBD;
        max-width: 140px;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        margin-top: 4px;
      }

      /* Thumbnail placeholder for images being cached. */
      .thumbnail-placeholder {
        width: 134px;
        height: 100px;
        background: #333;
        border: 4px solid #555;
        display: flex;
        align-items: center;
        justify-content: center;
        position: relative;
        cursor: pointer;
      }
      .thumbnail-placeholder:hover {
        border-color: #B8956A;
      }
      .thumbnail-placeholder .spinner {
        width: 24px;
        height: 24px;
        border: 3px solid #555;
        border-top-color: #B8956A;
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }
      @keyframes spin {
        to { transform: rotate(360deg); }
      }
      .thumbnail-placeholder .label {
        position: absolute;
        bottom: 4px;
        font-size: 0.65em;
        color: #888;
      }

      .bad {
        color: red;
        background-color: black;
      }
      .good {
        color: green;
        background-color: white;
      }

      /* Upload drop zone. */
      .drop-zone {
        border: 3px dashed #6B5344;
        border-radius: 8px;
        padding: 30px 20px;
        text-align: center;
        cursor: pointer;
        transition: all 0.2s;
        background: rgba(58, 42, 31, 0.3);
        min-height: 120px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
      }
      .drop-zone:hover {
        border-color: #B8956A;
        background: rgba(58, 42, 31, 0.5);
      }
      .drop-zone.drag-over {
        border-color: #B8956A;
        background: rgba(184, 149, 106, 0.2);
        border-style: solid;
      }
      .drop-zone.has-file {
        border-style: solid;
        border-color: #6B8E4E;
        background: rgba(107, 142, 78, 0.1);
      }
      .drop-zone-prompt {
        color: #C9DBBD;
        font-size: 1.1em;
        margin-bottom: 8px;
      }
      .drop-zone-hint {
        color: #888;
        font-size: 0.85em;
      }
      .drop-zone input[type="file"] {
        display: none;
      }
      .drop-zone-preview {
        display: none;
      }
      .drop-zone.has-file .drop-zone-prompt,
      .drop-zone.has-file .drop-zone-hint {
        display: none;
      }
      .drop-zone.has-file .drop-zone-preview {
        display: block;
      }
      .drop-zone-preview img {
        max-width: 200px;
        max-height: 150px;
        border: 2px solid #444;
        margin-bottom: 10px;
        border-radius: 4px;
      }
      .drop-zone-preview .file-name {
        font-weight: bold;
        color: #C9DBBD;
        word-break: break-all;
        margin-bottom: 4px;
      }
      .drop-zone-preview .file-size {
        color: #888;
        font-size: 0.9em;
      }

      /* Detail view. */
      .detail-header {
        display: flex;
        align-items: center;
        gap: 15px;
        margin-bottom: 20px;
        padding-bottom: 15px;
        border-bottom: 2px solid #6B5344;
        flex-wrap: wrap;
      }
      .back-button {
        background: #3A2A1F;
        border: 2px solid #6B5344;
        color: #C9DBBD;
        padding: 10px 20px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 1em;
        transition: all 0.2s;
        white-space: nowrap;
      }
      .back-button:hover {
        border-color: #B8956A;
        background: rgba(184, 149, 106, 0.2);
      }
      .detail-filename {
        flex: 1;
        color: #B8956A;
        font-size: 1.3em;
        font-weight: bold;
        word-break: break-all;
        min-width: 200px;
      }
      .delete-button {
        background: #3A2A1F;
        border: 2px solid #8B0000;
        color: #ff6b6b;
        padding: 10px 20px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 1em;
        transition: all 0.2s;
      }
      .delete-button:hover {
        background: #8B0000;
        color: #fff;
      }

      /* Pipeline flow layout. */
      .pipeline {
        display: flex;
        flex-direction: row;
        align-items: flex-start;
        gap: 0;
      }

      .pipeline-stage {
        display: flex;
        flex-direction: column;
        align-items: center;
        text-align: center;
      }

      .pipeline-stage canvas {
        border: 3px solid #444;
        border-radius: 4px;
        max-width: 100%;
        height: auto;
      }

      .pipeline-stage-label {
        color: #888;
        font-size: 0.85em;
        margin-top: 8px;
      }

      .pipeline-connector {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 15px 10px;
        min-width: 120px;
      }

      .pipeline-arrow {
        color: #B8956A;
        font-size: 2em;
        margin: 10px 0;
      }

      .pipeline-control {
        background: rgba(58, 42, 31, 0.5);
        border: 2px solid #6B5344;
        border-radius: 8px;
        padding: 12px 15px;
        min-width: 100px;
      }

      .pipeline-control-label {
        color: #C9DBBD;
        font-size: 0.8em;
        margin-bottom: 8px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      /* Filter buttons in pipeline. */
      .filter-buttons {
        display: flex;
        flex-direction: column;
        gap: 6px;
      }
      .filter-btn {
        padding: 6px 12px;
        border: 2px solid #6B5344;
        background: #3A2A1F;
        color: #C9DBBD;
        border-radius: 4px;
        cursor: pointer;
        transition: all 0.2s;
        font-size: 0.85em;
      }
      .filter-btn:hover {
        border-color: #B8956A;
      }
      .filter-btn.active {
        background: #B8956A;
        color: #2A1A0F;
        border-color: #B8956A;
      }

      /* Saturation slider in pipeline. */
      .saturation-slider {
        width: 100%;
        margin: 5px 0;
      }
      .saturation-value {
        color: #B8956A;
        font-weight: bold;
        font-size: 0.9em;
      }

      /* Final connector (just arrow). */
      .pipeline-connector-final {
        min-width: auto;
        padding: 15px 5px;
      }

      /* Flash section at end of pipeline. */
      .pipeline-flash {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 15px;
      }

      .flash-options {
        margin-bottom: 15px;
      }
      .flash-options label {
        color: #C9DBBD;
        font-size: 0.9em;
        cursor: pointer;
      }

      .flash-button {
        padding: 15px 30px;
        font-size: 1.1em;
        background: #6B8E4E;
        border: 2px solid #8BAF6E;
        color: #fff;
        border-radius: 4px;
        cursor: pointer;
        transition: all 0.2s;
        white-space: nowrap;
      }
      .flash-button:hover {
        background: #7BA05E;
      }
      .flash-button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      /* Processing indicator. */
      .processing-indicator {
        color: #6B8E4E;
        font-weight: bold;
        font-size: 0.85em;
        min-height: 1.2em;
        margin-top: 5px;
      }

      /* Filter status. */
      .filter-status {
        color: #6B8E4E;
        font-size: 0.8em;
        margin-top: 8px;
      }

      /* Apply filter button. */
      .apply-filter-btn {
        margin-top: 10px;
        padding: 6px 12px;
        font-size: 0.8em;
        background: #3A2A1F;
        border: 2px solid #6B5344;
        color: #C9DBBD;
        border-radius: 4px;
        cursor: pointer;
        transition: all 0.2s;
      }
      .apply-filter-btn:hover {
        border-color: #B8956A;
        background: rgba(184, 149, 106, 0.2);
      }

      /* Vertical layout for narrow screens. */
      @media (max-width: 1200px) {
        .pipeline {
          flex-direction: column;
          align-items: center;
        }

        .pipeline-connector {
          flex-direction: row;
          padding: 10px 15px;
          min-width: auto;
          width: 100%;
          max-width: 600px;
        }

        .pipeline-arrow {
          transform: rotate(90deg);
          margin: 0 15px;
        }

        .pipeline-control {
          flex: 1;
          min-width: auto;
        }

        .filter-buttons {
          flex-direction: row;
          flex-wrap: wrap;
          justify-content: center;
        }

        .pipeline-stage canvas {
          max-width: 600px;
        }

        .pipeline-flash {
          width: 100%;
          max-width: 600px;
        }

        .flash-button {
          width: 100%;
        }
      }

      /* Flash status bar (sticky bottom). */
      .flash-status-bar {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        background: #4A3728;
        border-top: 2px solid #B8956A;
        padding: 12px 20px;
        z-index: 999;
        transform: translateY(100%);
        transition: transform 0.3s ease;
      }
      .flash-status-bar.visible {
        transform: translateY(0);
      }
      .status-bar-content {
        display: flex;
        align-items: center;
        gap: 15px;
        max-width: 1200px;
        margin: 0 auto;
      }
      .status-icon {
        font-size: 1.5em;
      }
      .status-info {
        flex: 1;
      }
      .status-text {
        color: #C9DBBD;
        font-size: 0.95em;
        margin-bottom: 5px;
      }
      .status-progress-mini {
        height: 6px;
        background: #333;
        border-radius: 3px;
        overflow: hidden;
      }
      .status-progress-fill {
        height: 100%;
        background: linear-gradient(90deg, #B8956A, #6B8E4E);
        width: 0%;
        transition: width 0.5s linear;
      }
      .status-progress-fill.complete {
        background: #6B8E4E;
      }
      .status-progress-fill.failed {
        background: #ff6b6b;
      }
      .status-expand-btn {
        padding: 8px 16px;
        background: #3A2A1F;
        border: 2px solid #6B5344;
        color: #C9DBBD;
        border-radius: 4px;
        cursor: pointer;
        font-size: 0.9em;
        transition: all 0.2s;
      }
      .status-expand-btn:hover {
        border-color: #B8956A;
      }

      /* Upload modal. */
      .modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.85);
        z-index: 1000;
        justify-content: center;
        align-items: center;
      }
      .modal.active {
        display: flex;
      }
      .modal-content {
        background: #4A3728;
        border: 2px solid #B8956A;
        border-radius: 8px;
        padding: 30px;
        text-align: center;
        max-width: 500px;
        min-width: 320px;
        color: #C9DBBD;
      }
      .modal-content h2 {
        margin: 0 0 20px 0;
        color: #B8956A;
      }
      .modal-content img {
        max-width: 300px;
        max-height: 200px;
        border: 2px solid #444;
        margin-bottom: 15px;
      }
      .modal-content .filename {
        font-size: 0.9em;
        color: #aaa;
        margin-bottom: 20px;
        word-break: break-all;
      }
      .progress-container {
        margin: 15px 0;
      }
      .progress-label {
        font-size: 0.85em;
        color: #888;
        margin-bottom: 5px;
        text-align: left;
      }
      .progress-bar {
        width: 100%;
        height: 24px;
        background: #333;
        border-radius: 4px;
        overflow: hidden;
      }
      .progress-fill {
        height: 100%;
        width: 0%;
        background: linear-gradient(90deg, #B8956A, #6B8E4E);
        transition: width 0.5s linear;
      }
      .progress-fill.complete {
        background: #6B8E4E;
      }
      .upload-stats {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
        margin: 15px 0;
        font-size: 0.9em;
      }
      .upload-stats .stat {
        text-align: center;
      }
      .upload-stats .stat-value {
        font-size: 1.2em;
        font-weight: bold;
        color: #B8956A;
      }
      .upload-stats .stat-label {
        font-size: 0.8em;
        color: #888;
      }
      .modal-note {
        font-size: 0.8em;
        color: #666;
        margin-top: 15px;
      }

      /* Delete confirmation modal. */
      .confirm-modal-content {
        background: #4A3728;
        border: 2px solid #ff6b6b;
      }
      .confirm-modal-content h2 {
        color: #ff6b6b;
      }
      .confirm-modal-content .warning {
        font-size: 0.85em;
        color: #ff6b6b;
        margin-bottom: 20px;
      }
      .confirm-modal-footer {
        display: flex;
        gap: 15px;
        justify-content: center;
        margin-top: 20px;
      }
      .confirm-modal-footer button {
        padding: 10px 25px;
        font-size: 1em;
        border-radius: 4px;
        cursor: pointer;
        transition: all 0.2s;
      }
      .confirm-modal-footer .cancel-btn {
        background: #3A2A1F;
        border: 2px solid #6B5344;
        color: #C9DBBD;
      }
      .confirm-modal-footer .cancel-btn:hover {
        border-color: #B8956A;
      }
      .confirm-modal-footer .delete-btn {
        background: #8B0000;
        border: 2px solid #ff6b6b;
        color: #fff;
      }
      .confirm-modal-footer .delete-btn:hover {
        background: #a00;
      }

      /* Empty gallery state. */
      .empty-gallery {
        text-align: center;
        padding: 40px;
        color: #888;
      }
      .empty-gallery p {
        font-size: 1.1em;
        margin-bottom: 10px;
      }

      /* Mobile responsive. */
      @media (max-width: 768px) {
        .detail-header {
          flex-direction: column;
          align-items: stretch;
        }
        .detail-filename {
          order: -1;
          text-align: center;
          margin-bottom: 10px;
        }
        .detail-header .back-button,
        .detail-header .delete-button {
          flex: 1;
        }
        .status-bar-content {
          flex-wrap: wrap;
        }
        .status-info {
          min-width: 200px;
        }
        .pipeline-connector {
          padding: 8px 10px;
        }
        .pipeline-control {
          padding: 10px;
        }
        .filter-btn {
          padding: 8px 12px;
        }
      }
    </style>
    <title>inky-soup</title>
  </head>
  <body>
    <div class="container">
      <!-- Gallery View -->
      <div id="galleryView" class="view-container active">
        {% if errors | length >= 1 %}
          <small class="text-error" style="margin-top: 20px">
            Errors:
            {{ errors | length }} errors(s):
            {% for s in errors %}
              <p>{{s}}</p>
            {% endfor %}
          </small>
        {% endif %}

        {% if values | length >= 1 %}
          <small class="good" style="margin-top: 20px">
            {{ values | length }} Message(s):
            {% for v in values %}
              <p> {{v}} </p>
            {% endfor %}
          </small>
        {% endif %}

        <fieldset>
          <legend>Upload New Image</legend>
          <form id="uploadForm" action="/upload" method="post" enctype="multipart/form-data">
            <div id="dropZone" class="drop-zone">
              <input type="file" name="submission.file" id="fileInput" accept="image/*" />
              <div class="drop-zone-prompt">Drop image here or click to upload</div>
              <div class="drop-zone-hint">JPEG, PNG, GIF, WebP (max 10 MB)</div>
              <div class="drop-zone-preview">
                <img id="uploadPreviewImg" src="" alt="Preview" />
                <div id="uploadFileName" class="file-name"></div>
                <div id="uploadFileSize" class="file-size"></div>
              </div>
            </div>
          </form>
        </fieldset>

        <br>

        <fieldset>
          <legend>Gallery</legend>
          {% if images | length == 0 %}
            <div class="empty-gallery">
              <p>No images uploaded yet.</p>
              <p style="font-size: 0.9em;">Drop an image above to get started.</p>
            </div>
          {% else %}
            <div class="thumbnails">
              {% for img in images %}
              {%- set thumb_path = "images/thumbs/" ~ img.filename ~ ".png" -%}
              <div class="thumbnail-item" onclick="showDetailView('{{ img.filename }}', '{{ img.path }}', '{{ img.filter }}', {{ img.thumb_ready }})">
                {% if img.thumb_ready %}
                <img
                  src="{{ thumb_path }}"
                  alt="{{ img.filename }}"
                  loading="lazy"
                  data-filename="{{ img.filename }}"
                  data-path="{{ img.path }}"
                  data-filter="{{ img.filter }}"
                />
                {% else %}
                <div
                  class="thumbnail-placeholder"
                  id="placeholder-{{ img.filename }}"
                  data-filename="{{ img.filename }}"
                  data-path="{{ img.path }}"
                  data-filter="{{ img.filter }}"
                >
                  <div class="spinner"></div>
                  <span class="label">Caching...</span>
                </div>
                {% endif %}
                <div class="thumb-filename">
                  {%- if img.filename | length > 20 -%}
                    {%- set ext = img.filename | split(pat=".") | last -%}
                    {{ img.filename | replace(from="." ~ ext, to="") | truncate(length=15, end="...") }}.{{ ext }}
                  {%- else -%}
                    {{ img.filename }}
                  {%- endif -%}
                </div>
              </div>
              {% endfor %}
            </div>
          {% endif %}
        </fieldset>
      </div>

      <!-- Detail View -->
      <div id="detailView" class="view-container">
        <div class="detail-header">
          <button class="back-button" onclick="showGalleryView()">← Back to Gallery</button>
          <div id="detailFilename" class="detail-filename"></div>
          <button class="delete-button" onclick="showDeleteConfirmation()">Delete</button>
        </div>

        <!-- Hidden form field for delete. -->
        <form id="deleteForm" action="/delete" method="post" style="display: none;">
          <input type="hidden" name="submission.image_file_path" id="deleteImagePath" value="" />
        </form>

        <!-- Pipeline Flow -->
        <div class="pipeline">
          <!-- Stage 1: Filtered/Resized Image -->
          <div class="pipeline-stage">
            <canvas id="filterCanvas" width="600" height="448"></canvas>
            <div class="pipeline-stage-label">600 × 448 (resized)</div>
            <span id="filterProcessing" class="processing-indicator"></span>
          </div>

          <!-- Connector: Filter + Saturation Controls -->
          <div class="pipeline-connector">
            <div class="pipeline-control">
              <div class="pipeline-control-label">Resize Filter</div>
              <div class="filter-buttons">
                <button class="filter-btn" data-filter="bicubic">Bicubic</button>
                <button class="filter-btn" data-filter="lanczos">Lanczos</button>
                <button class="filter-btn" data-filter="mitchell">Mitchell</button>
                <button class="filter-btn" data-filter="bilinear">Bilinear</button>
                <button class="filter-btn" data-filter="nearest">Nearest</button>
              </div>
              <button class="apply-filter-btn" onclick="applyFilter()">Save</button>
              <span id="filterStatus" class="filter-status"></span>
            </div>
            <div class="pipeline-arrow">→</div>
            <div class="pipeline-control">
              <div class="pipeline-control-label">Saturation</div>
              <input type="range" id="saturationSlider" class="saturation-slider" min="0.1" max="1.0" step="0.1" value="0.5" oninput="updateSaturation(this.value)">
              <div class="saturation-value"><span id="saturationValue">0.5</span></div>
            </div>
            <div class="pipeline-arrow">→</div>
          </div>

          <!-- Stage 2: Dithered Image -->
          <div class="pipeline-stage">
            <canvas id="ditherCanvas" width="600" height="448"></canvas>
            <div class="pipeline-stage-label">600 × 448 (7 colors)</div>
            <span id="ditherProcessing" class="processing-indicator"></span>
          </div>

          <!-- Connector to Flash -->
          <div class="pipeline-connector pipeline-connector-final">
            <div class="pipeline-arrow">→</div>
          </div>

          <!-- Stage 3: Flash to Display -->
          <div class="pipeline-flash">
            <div class="flash-options">
              <label>
                <input type="checkbox" id="flashTwiceCheckbox">
                Flash twice
              </label>
            </div>
            <button id="flashBtn" class="flash-button" onclick="flashImage()">
              ⚡ Flash to Display
            </button>
          </div>
        </div>
      </div>
    </div>

    <!-- Flash Status Bar -->
    <div id="flashStatusBar" class="flash-status-bar">
      <div class="status-bar-content">
        <span id="statusIcon" class="status-icon">⚡</span>
        <div class="status-info">
          <div id="statusText" class="status-text">Idle</div>
          <div class="status-progress-mini">
            <div id="statusProgress" class="status-progress-fill"></div>
          </div>
        </div>
        <button class="status-expand-btn" onclick="expandFlashModal()">Details</button>
      </div>
    </div>

    <!-- Flash Progress Modal (expandable from status bar). -->
    <div id="flashModal" class="modal">
      <div class="modal-content">
        <h2 id="flashModalTitle">Flashing to Display</h2>
        <img id="flashModalImage" src="" alt=""/>
        <div id="flashModalFilename" class="filename"></div>

        <div id="flashProgress1Container" class="progress-container">
          <div class="progress-label">Flash 1</div>
          <div class="progress-bar">
            <div id="flashProgress1" class="progress-fill"></div>
          </div>
        </div>

        <div id="flashProgress2Container" class="progress-container" style="display: none;">
          <div class="progress-label">Flash 2</div>
          <div class="progress-bar">
            <div id="flashProgress2" class="progress-fill"></div>
          </div>
        </div>

        <div id="flashModalNote" class="modal-note">This takes about 40 seconds per flash...</div>
        <button type="button" id="flashModalClose" style="display: none; margin-top: 15px;" onclick="closeFlashModal()">Close</button>
      </div>
    </div>

    <!-- Upload Progress Modal. -->
    <div id="uploadModal" class="modal">
      <div class="modal-content">
        <h2 id="uploadModalTitle">Uploading Image</h2>
        <img id="uploadModalImage" src="" alt=""/>
        <div id="uploadModalFilename" class="filename"></div>

        <div id="uploadProgressContainer" class="progress-container">
          <div class="progress-label">Uploading</div>
          <div class="progress-bar">
            <div id="uploadProgress" class="progress-fill"></div>
          </div>
        </div>

        <div id="processingProgressContainer" class="progress-container" style="display: none;">
          <div class="progress-label">Processing</div>
          <div class="progress-bar">
            <div id="processingProgress" class="progress-fill"></div>
          </div>
        </div>

        <div class="upload-stats">
          <div class="stat">
            <div id="uploadPercent" class="stat-value">0%</div>
            <div class="stat-label">Progress</div>
          </div>
          <div class="stat">
            <div id="uploadSpeed" class="stat-value">-- MB/s</div>
            <div class="stat-label">Speed</div>
          </div>
          <div class="stat">
            <div id="uploadTransferred" class="stat-value">0 / 0 MB</div>
            <div class="stat-label">Transferred</div>
          </div>
          <div class="stat">
            <div id="uploadTime" class="stat-value">0:00</div>
            <div class="stat-label">Elapsed</div>
          </div>
        </div>

        <div id="uploadNote" class="modal-note">Uploading to server...</div>
        <button type="button" id="uploadCloseBtn" style="display: none; margin-top: 15px;" onclick="closeUploadModal()">Close</button>
      </div>
    </div>

    <!-- Delete Confirmation Modal. -->
    <div id="deleteConfirmModal" class="modal">
      <div class="modal-content confirm-modal-content">
        <h2>Delete Image?</h2>
        <p style="color: #C9DBBD;">You are about to delete:</p>
        <div id="deleteConfirmFilename" class="filename"></div>
        <div class="warning">This action cannot be undone.</div>
        <div class="confirm-modal-footer">
          <button type="button" class="cancel-btn" onclick="closeDeleteConfirmation()">Cancel</button>
          <button type="button" class="delete-btn" onclick="confirmDelete()">Delete</button>
        </div>
      </div>
    </div>

    <script src="/js/filters.js"></script>
    <script src="/js/dither.js"></script>
    <script>
      // Constants.
      const FLASH_DURATION_MS = 40000;
      const CACHE_WIDTH = 600;
      const CACHE_HEIGHT = 448;
      const THUMB_WIDTH = 150;
      const THUMB_HEIGHT = 112;

      // Current state.
      let currentView = 'gallery';
      let currentFilename = null;
      let currentPath = null;
      let currentFilter = 'bicubic';
      let currentSaturation = 0.5;

      // Worker state.
      let filterWorker = null;
      let ditherWorker = null;
      let originalImageCache = {};

      // Flash job tracking.
      let currentJobId = null;
      let pollInterval = null;

      // Upload workers.
      let uploadCacheWorker = null;
      let uploadThumbWorker = null;

      // ===============================
      // Navigation
      // ===============================

      function showGalleryView() {
        document.getElementById('detailView').classList.remove('active');
        document.getElementById('galleryView').classList.add('active');
        currentView = 'gallery';
        window.scrollTo(0, 0);
        history.pushState({ view: 'gallery' }, '', '#');
      }

      function showDetailView(filename, path, filter, thumbReady) {
        if (!thumbReady) {
          // Can't view detail for uncached images yet.
          alert('This image is still being processed. Please wait.');
          return;
        }

        currentFilename = filename;
        currentPath = path;
        currentFilter = filter || 'bicubic';
        currentSaturation = 0.5;

        // Update UI.
        document.getElementById('detailFilename').textContent = filename;
        document.getElementById('deleteImagePath').value = path;

        // Set active filter button.
        document.querySelectorAll('.filter-btn').forEach(btn => {
          btn.classList.toggle('active', btn.dataset.filter === currentFilter);
        });

        // Reset saturation.
        document.getElementById('saturationSlider').value = 0.5;
        document.getElementById('saturationValue').textContent = '0.5';

        // Reset flash twice.
        document.getElementById('flashTwiceCheckbox').checked = false;

        // Clear status.
        document.getElementById('filterStatus').textContent = '';
        document.getElementById('filterProcessing').textContent = 'Loading...';
        document.getElementById('ditherProcessing').textContent = '';

        // Clear canvases immediately to avoid showing previous image.
        const filterCanvas = document.getElementById('filterCanvas');
        const ditherCanvas = document.getElementById('ditherCanvas');
        const filterCtx = filterCanvas.getContext('2d');
        const ditherCtx = ditherCanvas.getContext('2d');

        // Fill with neutral background color.
        filterCtx.fillStyle = '#2A2A2A';
        filterCtx.fillRect(0, 0, filterCanvas.width, filterCanvas.height);
        ditherCtx.fillStyle = '#2A2A2A';
        ditherCtx.fillRect(0, 0, ditherCanvas.width, ditherCanvas.height);

        // Load image data for filter preview and dithering.
        loadImageForProcessing(filename);

        // Switch views.
        document.getElementById('galleryView').classList.remove('active');
        document.getElementById('detailView').classList.add('active');
        currentView = 'detail';
        window.scrollTo(0, 0);
        history.pushState({ view: 'detail', filename: filename }, '', '#detail-' + encodeURIComponent(filename));
      }

      // Handle browser back/forward.
      window.addEventListener('popstate', function(e) {
        if (e.state && e.state.view === 'detail' && e.state.filename) {
          // Try to find the thumbnail data.
          const thumb = document.querySelector(`img[data-filename="${e.state.filename}"]`);
          if (thumb) {
            showDetailView(e.state.filename, thumb.dataset.path, thumb.dataset.filter, true);
          } else {
            showGalleryView();
          }
        } else {
          showGalleryView();
        }
      });

      // ===============================
      // Image Loading & Processing
      // ===============================

      function loadImageForProcessing(filename) {
        // Try to load from server-side cache first (600x448 PNG already filtered).
        const cachedImg = new Image();
        cachedImg.crossOrigin = 'anonymous';
        cachedImg.onload = function() {
          // Cache exists - use it directly, skip filtering.
          document.getElementById('filterProcessing').textContent = '';

          // Draw cached image to filter canvas.
          const filterCanvas = document.getElementById('filterCanvas');
          const filterCtx = filterCanvas.getContext('2d');
          filterCtx.drawImage(cachedImg, 0, 0);

          // Get ImageData for dithering.
          const imageData = filterCtx.getImageData(0, 0, CACHE_WIDTH, CACHE_HEIGHT);
          applyDither(imageData);
        };
        cachedImg.onerror = function() {
          // Cache doesn't exist - fall back to loading and filtering original.
          loadOriginalAndFilter(filename);
        };
        cachedImg.src = 'images/cache/' + filename + '.png';
      }

      function loadOriginalAndFilter(filename) {
        // Check in-memory cache first.
        if (originalImageCache[filename]) {
          applyFilterFromImage(originalImageCache[filename]);
          return;
        }

        // Load the full original image.
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = function() {
          // Cache the image element.
          originalImageCache[filename] = img;

          // Apply filter.
          applyFilterFromImage(img);
        };
        img.onerror = function() {
          console.error('Failed to load image:', filename);
          document.getElementById('filterProcessing').textContent = 'Error loading image';
        };
        img.src = 'images/' + filename;
      }

      function applyFilterFromImage(img) {
        // Create fresh ImageData from the image element.
        const canvas = document.createElement('canvas');
        canvas.width = img.width;
        canvas.height = img.height;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0);
        const imageData = ctx.getImageData(0, 0, img.width, img.height);

        // Apply filter to the fresh ImageData.
        applyFilterToCanvas(imageData);
      }

      function applyFilterToCanvas(imageData) {
        document.getElementById('filterProcessing').textContent = 'Processing...';

        initFilterWorker();
        filterWorker.postMessage({
          data: imageData.data.buffer,
          width: imageData.width,
          height: imageData.height,
          targetWidth: CACHE_WIDTH,
          targetHeight: CACHE_HEIGHT,
          filter: currentFilter
        }, [imageData.data.buffer]);
      }

      function initFilterWorker() {
        if (filterWorker) return;

        filterWorker = new Worker('/js/filter-worker.js');
        filterWorker.onmessage = function(e) {
          const result = e.data;

          // Handle error responses.
          if (result.success === false) {
            console.error('Filter worker error:', result.error);
            document.getElementById('filterProcessing').textContent = 'Processing error';
            return;
          }

          // Result is ImageData transferred from worker.
          const imageData = result;

          // Draw to filter canvas.
          const filterCanvas = document.getElementById('filterCanvas');
          const filterCtx = filterCanvas.getContext('2d');
          filterCtx.putImageData(imageData, 0, 0);

          document.getElementById('filterProcessing').textContent = '';

          // Trigger dithering - get fresh ImageData from canvas (imageData is now neutered).
          const freshImageData = filterCtx.getImageData(0, 0, CACHE_WIDTH, CACHE_HEIGHT);
          applyDither(freshImageData);
        };
        filterWorker.onerror = function(e) {
          console.error('Filter worker error:', e);
          document.getElementById('filterProcessing').textContent = 'Processing error';
        };
      }

      // ===============================
      // Dithering
      // ===============================

      function applyDither(imageData) {
        document.getElementById('ditherProcessing').textContent = 'Dithering...';

        initDitherWorker();
        ditherWorker.postMessage({
          data: imageData.data.buffer,
          width: imageData.width,
          height: imageData.height,
          saturation: currentSaturation
        }, [imageData.data.buffer]);
      }

      function initDitherWorker() {
        if (ditherWorker) return;

        ditherWorker = new Worker('/js/dither-worker.js');
        ditherWorker.onmessage = function(e) {
          const result = e.data;

          // Handle error responses.
          if (result.success === false) {
            console.error('Dither worker error:', result.error);
            document.getElementById('ditherProcessing').textContent = 'Dithering error';
            return;
          }

          // Result is ImageData transferred from worker.
          const imageData = result;

          // Draw to dither canvas.
          const ditherCanvas = document.getElementById('ditherCanvas');
          const ditherCtx = ditherCanvas.getContext('2d');
          ditherCtx.putImageData(imageData, 0, 0);

          document.getElementById('ditherProcessing').textContent = '';
        };
        ditherWorker.onerror = function(e) {
          console.error('Dither worker error:', e);
          document.getElementById('ditherProcessing').textContent = 'Dithering error';
        };
      }

      function updateSaturation(value) {
        currentSaturation = parseFloat(value);
        document.getElementById('saturationValue').textContent = value;

        // Re-dither with new saturation.
        const filterCanvas = document.getElementById('filterCanvas');
        const filterCtx = filterCanvas.getContext('2d');
        const imageData = filterCtx.getImageData(0, 0, CACHE_WIDTH, CACHE_HEIGHT);
        applyDither(imageData);
      }

      // ===============================
      // Filter Application
      // ===============================

      function selectFilter(filter) {
        currentFilter = filter;

        // Update buttons.
        document.querySelectorAll('.filter-btn').forEach(btn => {
          btn.classList.toggle('active', btn.dataset.filter === filter);
        });

        // Re-process from original (bypass server cache since filter changed).
        if (originalImageCache[currentFilename]) {
          applyFilterFromImage(originalImageCache[currentFilename]);
        } else {
          loadOriginalAndFilter(currentFilename);
        }
      }

      // Set up filter button clicks.
      document.querySelectorAll('.filter-btn').forEach(btn => {
        btn.addEventListener('click', function() {
          selectFilter(this.dataset.filter);
        });
      });

      function applyFilter() {
        // Save the filtered image to the server.
        const filterCanvas = document.getElementById('filterCanvas');
        const statusEl = document.getElementById('filterStatus');

        statusEl.textContent = 'Saving...';

        filterCanvas.toBlob(function(cacheBlob) {
          // Upload cache image.
          const cacheFormData = new FormData();
          cacheFormData.append('filename', currentFilename);
          cacheFormData.append('filter', currentFilter);
          cacheFormData.append('file', cacheBlob, currentFilename + '.png');

          fetch('/api/upload-cache', { method: 'POST', body: cacheFormData })
            .then(r => r.json())
            .then(data => {
              if (!data.success) {
                statusEl.textContent = 'Error: ' + data.message;
                statusEl.style.color = '#ff4444';
                return;
              }

              // Also regenerate thumb.
              const thumbCanvas = document.createElement('canvas');
              thumbCanvas.width = THUMB_WIDTH;
              thumbCanvas.height = THUMB_HEIGHT;
              const thumbCtx = thumbCanvas.getContext('2d');
              thumbCtx.drawImage(filterCanvas, 0, 0, THUMB_WIDTH, THUMB_HEIGHT);

              thumbCanvas.toBlob(function(thumbBlob) {
                const thumbFormData = new FormData();
                thumbFormData.append('filename', currentFilename);
                thumbFormData.append('file', thumbBlob, currentFilename + '.png');

                fetch('/api/upload-thumb', { method: 'POST', body: thumbFormData })
                  .then(r => r.json())
                  .then(thumbData => {
                    statusEl.textContent = '✓ Filter saved';
                    statusEl.style.color = '#6B8E4E';

                    // Update gallery thumbnail if visible.
                    const galleryThumb = document.querySelector(`img[data-filename="${currentFilename}"]`);
                    if (galleryThumb) {
                      galleryThumb.src = thumbData.path + '?t=' + Date.now();
                      galleryThumb.dataset.filter = currentFilter;
                    }
                  });
              }, 'image/png');
            })
            .catch(err => {
              statusEl.textContent = 'Error: ' + err.message;
              statusEl.style.color = '#ff4444';
            });
        }, 'image/png');
      }

      // ===============================
      // Flash Image
      // ===============================

      function flashImage() {
        const flashBtn = document.getElementById('flashBtn');
        flashBtn.disabled = true;

        // Get dithered image.
        const ditherCanvas = document.getElementById('ditherCanvas');
        const flashTwice = document.getElementById('flashTwiceCheckbox').checked;

        ditherCanvas.toBlob(async function(blob) {
          try {
            // Upload dithered image.
            const uploadFormData = new FormData();
            uploadFormData.append('filename', currentFilename);
            uploadFormData.append('saturation', currentSaturation);
            uploadFormData.append('file', blob, currentFilename + '.png');

            const uploadResp = await fetch('/api/upload-dithered', {
              method: 'POST',
              body: uploadFormData
            });
            const uploadData = await uploadResp.json();

            if (!uploadData.success) {
              alert('Failed to upload dithered image: ' + uploadData.message);
              flashBtn.disabled = false;
              return;
            }

            // Submit flash job.
            const flashFormData = new FormData();
            flashFormData.append('submission.image_file_path', currentPath);
            if (flashTwice) {
              flashFormData.append('submission.flash_twice', 'yes');
            }

            const flashResp = await fetch('/flash', {
              method: 'POST',
              body: flashFormData
            });
            const flashData = await flashResp.json();

            if (!flashData.success) {
              alert('Failed to queue flash: ' + flashData.message);
              flashBtn.disabled = false;
              return;
            }

            // Start tracking the job.
            currentJobId = flashData.job_id;
            startFlashTracking(flashData.job_id, flashTwice);
            flashBtn.disabled = false;

          } catch (err) {
            alert('Error: ' + err.message);
            flashBtn.disabled = false;
          }
        }, 'image/png');
      }

      // ===============================
      // Flash Status Tracking
      // ===============================

      function startFlashTracking(jobId, flashTwice) {
        // Show status bar.
        const statusBar = document.getElementById('flashStatusBar');
        const statusText = document.getElementById('statusText');
        const statusProgress = document.getElementById('statusProgress');
        const statusIcon = document.getElementById('statusIcon');

        statusBar.classList.add('visible');
        statusText.textContent = 'Queued: ' + currentFilename;
        statusProgress.style.width = '0%';
        statusProgress.classList.remove('complete', 'failed');
        statusIcon.textContent = '⏳';

        // Set up flash modal.
        document.getElementById('flashModalImage').src = 'images/cache/' + currentFilename + '.png';
        document.getElementById('flashModalFilename').textContent = currentFilename;
        document.getElementById('flashModalTitle').textContent = 'Flash Job Queued';
        document.getElementById('flashModalTitle').style.color = '#B8956A';
        document.getElementById('flashModalNote').textContent = 'Waiting in queue...';
        document.getElementById('flashModalClose').style.display = 'none';
        document.getElementById('flashProgress1').style.width = '0%';
        document.getElementById('flashProgress1').classList.remove('complete');
        document.getElementById('flashProgress2').style.width = '0%';
        document.getElementById('flashProgress2').classList.remove('complete');
        document.getElementById('flashProgress2Container').style.display = flashTwice ? 'block' : 'none';
        document.querySelector('#flashProgress1Container .progress-label').textContent = flashTwice ? 'Flash 1' : 'Flashing...';

        // Start polling.
        if (pollInterval) clearInterval(pollInterval);
        pollInterval = setInterval(() => pollJobStatus(jobId, flashTwice), 1000);
      }

      async function pollJobStatus(jobId, flashTwice) {
        try {
          const resp = await fetch('/api/flash/status/' + jobId);
          if (!resp.ok) {
            // Job not found - stop polling.
            clearInterval(pollInterval);
            pollInterval = null;
            return;
          }

          const job = await resp.json();
          updateFlashStatus(job, flashTwice);

          // Stop polling if job is done.
          if (job.status === 'Completed' || job.status === 'Failed') {
            clearInterval(pollInterval);
            pollInterval = null;
          }
        } catch (err) {
          console.error('Poll error:', err);
        }
      }

      function updateFlashStatus(job, flashTwice) {
        const statusBar = document.getElementById('flashStatusBar');
        const statusText = document.getElementById('statusText');
        const statusProgress = document.getElementById('statusProgress');
        const statusIcon = document.getElementById('statusIcon');
        const modalTitle = document.getElementById('flashModalTitle');
        const modalNote = document.getElementById('flashModalNote');
        const closeBtn = document.getElementById('flashModalClose');

        switch (job.status) {
          case 'Queued':
            statusIcon.textContent = '⏳';
            statusText.textContent = 'Queued: ' + job.filename;
            statusProgress.style.width = '0%';
            modalTitle.textContent = 'Flash Job Queued';
            modalNote.textContent = 'Waiting in queue...';
            break;

          case 'Flashing':
            statusIcon.textContent = '⚡';
            statusText.textContent = 'Flashing: ' + job.filename;
            modalTitle.textContent = 'Flashing to Display';
            modalNote.textContent = 'This takes about 40 seconds per flash...';

            // Calculate progress based on elapsed time.
            if (job.started_at) {
              const elapsed = Date.now() - job.started_at;
              const totalDuration = flashTwice ? FLASH_DURATION_MS * 2 : FLASH_DURATION_MS;
              const progress = Math.min(95, (elapsed / totalDuration) * 100);
              statusProgress.style.width = progress + '%';

              // Update modal progress bars.
              const progress1 = Math.min(100, (elapsed / FLASH_DURATION_MS) * 100);
              document.getElementById('flashProgress1').style.width = progress1 + '%';

              if (flashTwice && elapsed > FLASH_DURATION_MS) {
                document.getElementById('flashProgress1').classList.add('complete');
                const progress2 = Math.min(100, ((elapsed - FLASH_DURATION_MS) / FLASH_DURATION_MS) * 100);
                document.getElementById('flashProgress2').style.width = progress2 + '%';
              }
            }
            break;

          case 'Completed':
            statusIcon.textContent = '✓';
            statusText.textContent = 'Complete: ' + job.filename;
            statusProgress.style.width = '100%';
            statusProgress.classList.add('complete');
            document.getElementById('flashProgress1').style.width = '100%';
            document.getElementById('flashProgress1').classList.add('complete');
            if (flashTwice) {
              document.getElementById('flashProgress2').style.width = '100%';
              document.getElementById('flashProgress2').classList.add('complete');
            }
            modalTitle.textContent = '✓ Flash Complete!';
            modalTitle.style.color = '#6B8E4E';
            modalNote.textContent = 'Image sent to display.';
            closeBtn.style.display = 'block';

            // Hide status bar after 5 seconds.
            setTimeout(() => {
              statusBar.classList.remove('visible');
            }, 5000);
            break;

          case 'Failed':
            statusIcon.textContent = '✗';
            statusText.textContent = 'Failed: ' + job.filename;
            statusProgress.style.width = '100%';
            statusProgress.classList.add('failed');
            modalTitle.textContent = '✗ Flash Failed';
            modalTitle.style.color = '#ff6b6b';
            modalNote.textContent = job.error_message || 'Unknown error';
            closeBtn.style.display = 'block';
            break;
        }
      }

      function expandFlashModal() {
        document.getElementById('flashModal').classList.add('active');
      }

      function closeFlashModal() {
        document.getElementById('flashModal').classList.remove('active');
      }

      // ===============================
      // Delete
      // ===============================

      function showDeleteConfirmation() {
        document.getElementById('deleteConfirmFilename').textContent = currentFilename;
        document.getElementById('deleteConfirmModal').classList.add('active');
      }

      function closeDeleteConfirmation() {
        document.getElementById('deleteConfirmModal').classList.remove('active');
      }

      function confirmDelete() {
        closeDeleteConfirmation();
        document.getElementById('deleteForm').submit();
      }

      // ===============================
      // Upload Handling
      // ===============================

      const dropZone = document.getElementById('dropZone');
      const fileInput = document.getElementById('fileInput');

      dropZone.addEventListener('click', () => fileInput.click());
      dropZone.addEventListener('dragover', (e) => {
        e.preventDefault();
        dropZone.classList.add('drag-over');
      });
      dropZone.addEventListener('dragleave', () => {
        dropZone.classList.remove('drag-over');
      });
      dropZone.addEventListener('drop', (e) => {
        e.preventDefault();
        dropZone.classList.remove('drag-over');
        const files = e.dataTransfer.files;
        if (files.length > 0) {
          handleFileSelect(files[0]);
        }
      });
      fileInput.addEventListener('change', (e) => {
        if (e.target.files.length > 0) {
          handleFileSelect(e.target.files[0]);
        }
      });

      function handleFileSelect(file) {
        // Validate file type.
        const validTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];
        if (!validTypes.includes(file.type)) {
          alert('Please select a valid image file (JPEG, PNG, GIF, or WebP).');
          return;
        }

        // Validate size (10MB max).
        if (file.size > 10 * 1024 * 1024) {
          alert('File is too large. Maximum size is 10 MB.');
          return;
        }

        // Show upload modal.
        const modal = document.getElementById('uploadModal');
        const modalImg = document.getElementById('uploadModalImage');
        const modalFilename = document.getElementById('uploadModalFilename');
        const progressEl = document.getElementById('uploadProgress');
        const percentEl = document.getElementById('uploadPercent');
        const speedEl = document.getElementById('uploadSpeed');
        const transferredEl = document.getElementById('uploadTransferred');
        const timeEl = document.getElementById('uploadTime');
        const noteEl = document.getElementById('uploadNote');
        const closeBtn = document.getElementById('uploadCloseBtn');
        const titleEl = document.getElementById('uploadModalTitle');
        const processingContainer = document.getElementById('processingProgressContainer');
        const processingEl = document.getElementById('processingProgress');

        // Reset modal state.
        titleEl.textContent = 'Uploading Image';
        titleEl.style.color = '#B8956A';
        progressEl.style.width = '0%';
        progressEl.classList.remove('complete');
        processingContainer.style.display = 'none';
        processingEl.style.width = '0%';
        processingEl.classList.remove('complete');
        percentEl.textContent = '0%';
        speedEl.textContent = '-- MB/s';
        transferredEl.textContent = '0 / ' + formatSize(file.size);
        timeEl.textContent = '0:00';
        noteEl.textContent = 'Uploading to server...';
        closeBtn.style.display = 'none';

        // Preview image.
        const reader = new FileReader();
        reader.onload = (e) => {
          modalImg.src = e.target.result;

          // Start generating cache and thumb in parallel.
          generateThumbnails(e.target.result, file.name);
        };
        reader.readAsDataURL(file);
        modalFilename.textContent = file.name;

        modal.classList.add('active');

        // Upload with progress tracking.
        const formData = new FormData();
        formData.append('submission.file', file, file.name);

        const xhr = new XMLHttpRequest();
        const startTime = Date.now();

        xhr.upload.addEventListener('progress', (e) => {
          if (e.lengthComputable) {
            const percent = Math.round((e.loaded / e.total) * 100);
            const elapsed = (Date.now() - startTime) / 1000;
            const speed = e.loaded / elapsed;

            progressEl.style.width = percent + '%';
            percentEl.textContent = percent + '%';
            speedEl.textContent = formatSpeed(speed);
            transferredEl.textContent = formatSize(e.loaded) + ' / ' + formatSize(e.total);
            timeEl.textContent = formatTime(elapsed);
          }
        });

        xhr.addEventListener('load', () => {
          if (xhr.status === 200 || xhr.status === 303) {
            progressEl.style.width = '100%';
            progressEl.classList.add('complete');
            percentEl.textContent = '100%';
            noteEl.textContent = 'Upload complete! Processing thumbnails...';

            // Show processing progress.
            processingContainer.style.display = 'block';

            // Wait for thumbnails to finish (they started in parallel).
            checkThumbnailsReady(file.name, titleEl, noteEl, closeBtn, processingEl);
          } else {
            titleEl.textContent = '✗ Upload Failed';
            titleEl.style.color = '#ff6b6b';
            noteEl.textContent = 'Server returned error: ' + xhr.status;
            closeBtn.style.display = 'block';
          }
        });

        xhr.addEventListener('error', () => {
          titleEl.textContent = '✗ Upload Failed';
          titleEl.style.color = '#ff6b6b';
          noteEl.textContent = 'Network error occurred.';
          closeBtn.style.display = 'block';
        });

        xhr.open('POST', '/upload');
        xhr.send(formData);
      }

      let pendingThumbnails = { cache: null, thumb: null };

      function generateThumbnails(dataUrl, filename) {
        const img = new Image();
        img.onload = function() {
          // Generate cache (600x448).
          const cacheCanvas = document.createElement('canvas');
          cacheCanvas.width = CACHE_WIDTH;
          cacheCanvas.height = CACHE_HEIGHT;
          const cacheCtx = cacheCanvas.getContext('2d');

          // Use simple draw for initial cache (bicubic is default).
          cacheCtx.drawImage(img, 0, 0, CACHE_WIDTH, CACHE_HEIGHT);

          cacheCanvas.toBlob(function(cacheBlob) {
            pendingThumbnails.cache = { blob: cacheBlob, filename: filename };
            uploadPendingThumbnails(filename);
          }, 'image/png');

          // Generate thumb (150x112).
          const thumbCanvas = document.createElement('canvas');
          thumbCanvas.width = THUMB_WIDTH;
          thumbCanvas.height = THUMB_HEIGHT;
          const thumbCtx = thumbCanvas.getContext('2d');
          thumbCtx.drawImage(img, 0, 0, THUMB_WIDTH, THUMB_HEIGHT);

          thumbCanvas.toBlob(function(thumbBlob) {
            pendingThumbnails.thumb = { blob: thumbBlob, filename: filename };
            uploadPendingThumbnails(filename);
          }, 'image/png');
        };
        img.src = dataUrl;
      }

      function uploadPendingThumbnails(filename) {
        // Wait for both thumbnails to be ready.
        if (!pendingThumbnails.cache || !pendingThumbnails.thumb) return;
        if (pendingThumbnails.cache.filename !== filename || pendingThumbnails.thumb.filename !== filename) return;

        const cache = pendingThumbnails.cache;
        const thumb = pendingThumbnails.thumb;

        // Upload cache.
        const cacheFormData = new FormData();
        cacheFormData.append('filename', filename);
        cacheFormData.append('filter', 'bicubic');
        cacheFormData.append('file', cache.blob, filename + '.png');

        fetch('/api/upload-cache', { method: 'POST', body: cacheFormData })
          .then(r => r.json())
          .then(data => {
            if (!data.success) {
              console.error('Cache upload failed:', data.message);
            }
          });

        // Upload thumb.
        const thumbFormData = new FormData();
        thumbFormData.append('filename', filename);
        thumbFormData.append('file', thumb.blob, filename + '.png');

        fetch('/api/upload-thumb', { method: 'POST', body: thumbFormData })
          .then(r => r.json())
          .then(data => {
            if (!data.success) {
              console.error('Thumb upload failed:', data.message);
            }
            // Mark thumbnails as uploaded.
            pendingThumbnails.uploaded = true;
          });
      }

      function checkThumbnailsReady(filename, titleEl, noteEl, closeBtn, processingEl) {
        // Poll until thumbnails are uploaded.
        const checkInterval = setInterval(() => {
          if (pendingThumbnails.uploaded) {
            clearInterval(checkInterval);
            processingEl.style.width = '100%';
            processingEl.classList.add('complete');
            titleEl.textContent = '✓ Upload Complete!';
            titleEl.style.color = '#6B8E4E';
            noteEl.textContent = 'Image and thumbnails ready.';
            closeBtn.style.display = 'block';

            // Reset pending state.
            pendingThumbnails = { cache: null, thumb: null };
          } else {
            // Animate processing bar.
            const current = parseFloat(processingEl.style.width) || 0;
            processingEl.style.width = Math.min(90, current + 10) + '%';
          }
        }, 200);
      }

      function closeUploadModal() {
        document.getElementById('uploadModal').classList.remove('active');
        window.location.reload();
      }

      // ===============================
      // Utility Functions
      // ===============================

      function formatSize(bytes) {
        if (bytes < 1024) return bytes + ' B';
        if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
        return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
      }

      function formatSpeed(bytesPerSec) {
        if (bytesPerSec < 1024) return bytesPerSec.toFixed(0) + ' B/s';
        if (bytesPerSec < 1024 * 1024) return (bytesPerSec / 1024).toFixed(1) + ' KB/s';
        return (bytesPerSec / (1024 * 1024)).toFixed(2) + ' MB/s';
      }

      function formatTime(seconds) {
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return mins + ':' + (secs < 10 ? '0' : '') + secs;
      }

      // ===============================
      // Placeholder Polling
      // ===============================

      // Poll for thumbnail status on uncached images.
      document.querySelectorAll('.thumbnail-placeholder').forEach(placeholder => {
        const filename = placeholder.dataset.filename;
        const path = placeholder.dataset.path;
        pollThumbStatus(filename, path, placeholder);
      });

      function pollThumbStatus(filename, path, placeholderEl) {
        fetch('/api/thumb-status/' + encodeURIComponent(filename))
          .then(r => r.json())
          .then(data => {
            if (data.ready) {
              replacePlaceholderWithThumb(filename, path, placeholderEl, data.thumb_path);
            } else {
              // Keep polling.
              setTimeout(() => pollThumbStatus(filename, path, placeholderEl), 2000);
            }
          })
          .catch(err => {
            console.error('Thumb status poll failed:', err);
            setTimeout(() => pollThumbStatus(filename, path, placeholderEl), 2000);
          });
      }

      function replacePlaceholderWithThumb(filename, path, placeholderEl, thumbPath) {
        const filter = placeholderEl.dataset.filter || 'bicubic';
        const img = document.createElement('img');
        img.src = thumbPath;
        img.alt = filename;
        img.loading = 'lazy';
        img.dataset.filename = filename;
        img.dataset.path = path;
        img.dataset.filter = filter;

        // Replace placeholder with image.
        placeholderEl.parentNode.replaceChild(img, placeholderEl);

        // Update the parent click handler.
        img.parentNode.onclick = function() {
          showDetailView(filename, path, filter, true);
        };
      }

      // ===============================
      // Global Flash Status Polling
      // ===============================

      // Check for any active flash jobs on page load.
      checkGlobalFlashStatus();

      async function checkGlobalFlashStatus() {
        try {
          const resp = await fetch('/api/flash/status');
          const data = await resp.json();

          if (data.current_job && (data.current_job.status === 'Queued' || data.current_job.status === 'Flashing')) {
            // There's an active job - show status bar and track it.
            currentJobId = data.current_job.job_id;
            const flashTwice = data.current_job.flash_twice;
            currentFilename = data.current_job.filename;

            const statusBar = document.getElementById('flashStatusBar');
            statusBar.classList.add('visible');

            // Set up tracking.
            if (!pollInterval) {
              pollInterval = setInterval(() => pollJobStatus(currentJobId, flashTwice), 1000);
            }

            // Update status immediately.
            updateFlashStatus(data.current_job, flashTwice);
          }
        } catch (err) {
          console.error('Failed to check global flash status:', err);
        }
      }
    </script>
  </body>
</html>
