{% import "macros" as m %}

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <link rel="stylesheet" href="/chota.min.css">
    <style>
      body {
        background-color: #A0826D;
      }
      .container {
        max-width: 1400px;
        margin: 0 auto;
        padding: 20px 10px;
      }
      .thumbnails img {
        height: 100px;
        border: 4px solid #555;
        padding: 1px;
        margin: 0 10px 10px 0;
      }
      .thumbnails img:hover {
        border: 4px solid #B8956A;
        cursor:pointer;
      }
      .thumbnails img.selected {
        border: 4px solid #B8956A;
      }
      .preview img {
        border: 4px solid #444;
        padding: 1px;
        width: 600px;
      }
      .bad {
        color: red;
        background-color: black;
      }
      .good {
        color: green;
        background-color: white;
      }

      /* Flash progress modal. */
      .flash-modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.85);
        z-index: 1000;
        justify-content: center;
        align-items: center;
      }
      .flash-modal.active {
        display: flex;
      }
      .flash-modal-content {
        background: #4A3728;
        border: 2px solid #B8956A;
        border-radius: 8px;
        padding: 30px;
        text-align: center;
        max-width: 500px;
        color: #C9DBBD;
      }
      .flash-modal-content h2 {
        margin: 0 0 20px 0;
        color: #B8956A;
      }
      .flash-modal-content img {
        max-width: 300px;
        max-height: 200px;
        border: 2px solid #444;
        margin-bottom: 15px;
      }
      .flash-modal-content .filename {
        font-size: 0.9em;
        color: #aaa;
        margin-bottom: 20px;
        word-break: break-all;
      }
      .progress-container {
        margin: 15px 0;
      }
      .progress-label {
        font-size: 0.85em;
        color: #888;
        margin-bottom: 5px;
        text-align: left;
      }
      .progress-bar {
        width: 100%;
        height: 24px;
        background: #333;
        border-radius: 4px;
        overflow: hidden;
      }
      .progress-fill {
        height: 100%;
        width: 0%;
        background: linear-gradient(90deg, #B8956A, #6B8E4E);
        transition: width 0.5s linear;
      }
      .progress-fill.complete {
        background: #6B8E4E;
      }
      .flash-note {
        font-size: 0.8em;
        color: #666;
        margin-top: 15px;
      }

      /* Upload preview area. */
      .upload-preview {
        display: none;
        margin: 15px 0;
        padding: 15px;
        background: #f5f5f5;
        border-radius: 8px;
        text-align: center;
      }
      .upload-preview.active {
        display: block;
      }
      .upload-preview img {
        max-width: 200px;
        max-height: 150px;
        border: 2px solid #444;
        margin-bottom: 10px;
      }
      .upload-preview .file-info {
        font-size: 0.9em;
        color: #666;
      }
      .upload-preview .file-name {
        font-weight: bold;
        word-break: break-all;
      }
      .upload-preview .file-size {
        color: #888;
      }

      /* Upload modal (extends flash modal pattern). */
      .upload-modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.85);
        z-index: 1000;
        justify-content: center;
        align-items: center;
      }
      .upload-modal.active {
        display: flex;
      }
      .upload-modal-content {
        background: #4A3728;
        border: 2px solid #B8956A;
        border-radius: 8px;
        padding: 30px;
        text-align: center;
        max-width: 500px;
        min-width: 350px;
        color: #C9DBBD;
      }
      .upload-modal-content h2 {
        margin: 0 0 20px 0;
        color: #B8956A;
      }
      .upload-modal-content img {
        max-width: 300px;
        max-height: 200px;
        border: 2px solid #444;
        margin-bottom: 15px;
      }
      .upload-modal-content .filename {
        font-size: 0.9em;
        color: #aaa;
        margin-bottom: 20px;
        word-break: break-all;
      }
      .upload-stats {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
        margin: 15px 0;
        font-size: 0.9em;
      }
      .upload-stats .stat {
        text-align: center;
      }
      .upload-stats .stat-value {
        font-size: 1.2em;
        font-weight: bold;
        color: #B8956A;
      }
      .upload-stats .stat-label {
        font-size: 0.8em;
        color: #888;
      }
      .upload-note {
        font-size: 0.8em;
        color: #666;
        margin-top: 15px;
      }

      /* Thumbnail placeholder for images being cached. */
      .thumbnail-placeholder {
        width: 134px;
        height: 100px;
        background: #333;
        border: 4px solid #555;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        margin: 0 10px 10px 0;
        position: relative;
        cursor: pointer;
      }
      .thumbnail-placeholder:hover {
        border-color: #B8956A;
      }
      .thumbnail-placeholder.selected {
        border-color: #B8956A;
      }
      .thumbnail-placeholder .spinner {
        width: 24px;
        height: 24px;
        border: 3px solid #555;
        border-top-color: #B8956A;
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }
      @keyframes spin {
        to { transform: rotate(360deg); }
      }
      .thumbnail-placeholder .label {
        position: absolute;
        bottom: 4px;
        font-size: 0.65em;
        color: #888;
      }

      /* Filter editor modal. */
      .filter-editor-modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.9);
        z-index: 2000;
        justify-content: center;
        align-items: center;
      }
      .filter-editor-modal.active {
        display: flex;
      }
      .filter-editor-content {
        background: #4A3728;
        border: 2px solid #B8956A;
        border-radius: 8px;
        padding: 30px;
        max-width: 800px;
        max-height: 90vh;
        overflow-y: auto;
        color: #C9DBBD;
      }
      /* Wider modal for dither preview with side-by-side comparison. */
      #ditherPreviewModal .filter-editor-content {
        max-width: 1300px;
      }
      /* On tall/narrow screens, use more vertical space for dither preview. */
      @media (max-aspect-ratio: 4/3) {
        #ditherPreviewModal .filter-editor-content {
          max-height: 95vh;
          padding: 15px;
        }
      }
      .filter-editor-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
      }
      .filter-editor-header h2 {
        margin: 0;
        color: #B8956A;
      }
      .filter-editor-header button {
        background: none;
        border: none;
        color: #C9DBBD;
        font-size: 2em;
        cursor: pointer;
        padding: 0;
        line-height: 1;
      }
      .filter-editor-body {
        text-align: center;
      }
      #filterCanvas {
        border: 2px solid #444;
        margin-bottom: 20px;
        max-width: 100%;
        height: auto;
      }
      .filter-controls {
        margin: 20px 0;
      }
      .filter-buttons {
        display: flex;
        gap: 10px;
        justify-content: center;
        flex-wrap: wrap;
        margin: 15px 0;
      }
      .filter-buttons button {
        padding: 10px 20px;
        font-size: 1em;
        border: 2px solid #6B5344;
        background: #3A2A1F;
        color: #C9DBBD;
        cursor: pointer;
        border-radius: 4px;
        transition: all 0.2s;
      }
      .filter-buttons button:hover {
        border-color: #B8956A;
      }
      .filter-buttons button.active {
        background: #B8956A;
        color: #2A1A0F;
        border-color: #B8956A;
      }
      .processing-indicator {
        font-size: 0.9em;
        color: #B8956A;
        min-height: 1.5em;
      }

      /* Before/after comparison layout. */
      .comparison-container {
        display: flex;
        gap: 20px;
        justify-content: center;
        align-items: center;
        flex-wrap: wrap;
        margin-bottom: 20px;
      }
      @media (max-aspect-ratio: 4/3) {
        .comparison-container {
          flex-direction: column;
        }
      }
      .comparison-panel {
        text-align: center;
      }
      .comparison-panel canvas {
        border: 2px solid #444;
        max-width: 100%;
        height: auto;
      }
      .comparison-label {
        font-weight: bold;
        color: #B8956A;
        margin-bottom: 8px;
      }
      .comparison-dimensions {
        font-size: 0.85em;
        color: #888;
        margin-top: 5px;
      }

      .filter-editor-footer {
        display: flex;
        gap: 10px;
        justify-content: flex-end;
        margin-top: 20px;
      }

      /* Disabled button styling. */
      #uploadBtn:disabled,
      #flashBtn:disabled,
      #editFilterBtn:disabled,
      #filterSelect:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
    </style>
  <title>inky-soup - upload</title>
  </head>
  <body>
    <div class="container">

      {% if errors | length >= 1 %}
        <small class="text-error" style="margin-top: 20px">
          Errors:
          {{ errors | length }} errors(s):
          {% for s in errors %}
            <p>{{s}}</p>
          {% endfor %}
        </small>
      {% endif %}

      {% if values | length >= 1 %}
        <small class="good" style="margin-top: 20px">
          {{ values | length }} Message(s):
          {% for v in values %}
            <p> {{v}} </p>
          {% endfor %}
        </small>
      {% endif %}

      <fieldset>
        <legend>Upload New Image</legend>

        <form id="uploadForm" action="/upload" method="post" enctype="multipart/form-data">

            {{
                m::input(
                    label="File to Upload (Image, max 10MiB)",
                    type="file",
                    name="submission.file"
                )
            }}

          <div id="uploadPreview" class="upload-preview">
            <img id="uploadPreviewImg" src="" alt="Preview" />
            <div class="file-info">
              <div id="uploadFileName" class="file-name"></div>
              <div id="uploadFileSize" class="file-size"></div>
            </div>
          </div>

          <br />
          <input type="submit" id="uploadBtn" value="Upload Image" disabled />
        </form>
      </fieldset>
      <br />

      <form action="/flash" method="post" enctype="multipart/form-data">
      <div class="row">
        <div class="col">
            <fieldset>
              <legend>Select an Image</legend>
              <div class="thumbnails">

                <div class="row">
                  {% for img in images %}
                  {%- set thumb_path = "images/thumbs/" ~ img.filename ~ ".png" -%}
                  <div class="col" style="text-align: center;">
                    {% if img.thumb_ready %}
                    <img
                      onclick="selectThumbnail(this)"
                      id="{{ img.path }}"
                      src="{{ thumb_path }}"
                      alt="{{ img.path }}"
                      loading="lazy"
                      data-filter="{{ img.filter }}"
                      data-filename="{{ img.filename }}"
                    />
                    {% else %}
                    <div
                      class="thumbnail-placeholder"
                      id="{{ img.path }}"
                      onclick="selectPlaceholder(this)"
                      data-filename="{{ img.filename }}"
                      data-path="{{ img.path }}"
                      data-filter="{{ img.filter }}"
                    >
                      <div class="spinner"></div>
                      <span class="label">Caching...</span>
                    </div>
                    {% endif %}
                    <div style="font-size: 0.75em;">
                      {%- if img.filename | length > 40 -%}
                        {%- set ext = img.filename | split(pat=".") | last -%}
                        {{ img.filename | replace(from="." ~ ext, to="") | truncate(length=32, end="...") }}.{{ ext }}
                      {%- else -%}
                        {{ img.filename }}
                      {%- endif -%}
                    </div>
                  </div>
                  {% endfor %}
                </div>

              </div>
            </fieldset>

            <input type="submit" id="flashBtn" value="Flash Image" class="is-full-width" disabled />

            <br>

            <input type="submit" formaction="/delete" value="Remove Image (warning there is no confirmation and this is permanent)" class="bad"/>
        </div>

        <fieldset>
          <legend>Selected Image</legend>
          {{
              m::input(
                  label="Filename:",
                  name="submission.image_file_path"
              )
          }}
          <br>

          <div style="margin-bottom: 15px;">
            <label for="filterSelect" style="font-weight: bold;">Resampling Filter:</label>
            <select id="filterSelect" style="margin-left: 10px;" disabled>
              <option value="bicubic">Bicubic (Balanced)</option>
              <option value="lanczos">Lanczos (Sharp)</option>
              <option value="bilinear">Bilinear (Smooth)</option>
              <option value="nearest">Nearest (Fast)</option>
            </select>
            <button type="button" id="editFilterBtn" onclick="openFilterEditor()" style="margin-left: 10px;" class="button" disabled>Edit Filter...</button>
            <span id="filterStatus" style="margin-left: 10px; font-size: 0.85em; color: #666;"></span>
          </div>

          Preview:
          <div class="preview" align="center">
            <img id="preview" src="" alt=""/>
          </div>
        </fieldset>

      </div>
      </form>

    </div>

    <!-- Flash progress modal. -->
    <div id="flashModal" class="flash-modal">
      <div class="flash-modal-content">
        <h2>Flashing to Display</h2>
        <img id="modalImage" src="" alt=""/>
        <div id="modalFilename" class="filename"></div>

        <div id="progress1Container" class="progress-container">
          <div class="progress-label">Flash 1</div>
          <div class="progress-bar">
            <div id="progress1" class="progress-fill"></div>
          </div>
        </div>

        <div id="progress2Container" class="progress-container" style="display: none;">
          <div class="progress-label">Flash 2</div>
          <div class="progress-bar">
            <div id="progress2" class="progress-fill"></div>
          </div>
        </div>

        <div id="flashNote" class="flash-note">This takes about 40 seconds per flash...</div>
        <button type="button" id="flashCloseBtn" style="display: none; margin-top: 15px;" onclick="document.getElementById('flashModal').classList.remove('active');">Close</button>
      </div>
    </div>

    <!-- Upload progress modal. -->
    <div id="uploadModal" class="upload-modal">
      <div class="upload-modal-content">
        <h2 id="uploadModalTitle">Uploading Image</h2>
        <img id="uploadModalImage" src="" alt=""/>
        <div id="uploadModalFilename" class="filename"></div>

        <div id="uploadProgressContainer" class="progress-container">
          <div class="progress-label">Uploading</div>
          <div class="progress-bar">
            <div id="uploadProgress" class="progress-fill"></div>
          </div>
        </div>

        <div id="processingProgressContainer" class="progress-container" style="display: none;">
          <div class="progress-label">Processing</div>
          <div class="progress-bar">
            <div id="processingProgress" class="progress-fill"></div>
          </div>
        </div>

        <div class="upload-stats">
          <div class="stat">
            <div id="uploadPercent" class="stat-value">0%</div>
            <div class="stat-label">Progress</div>
          </div>
          <div class="stat">
            <div id="uploadSpeed" class="stat-value">-- MB/s</div>
            <div class="stat-label">Speed</div>
          </div>
          <div class="stat">
            <div id="uploadTransferred" class="stat-value">0 / 0 MB</div>
            <div class="stat-label">Transferred</div>
          </div>
          <div class="stat">
            <div id="uploadTime" class="stat-value">0:00</div>
            <div class="stat-label">Elapsed</div>
          </div>
        </div>

        <div id="uploadNote" class="upload-note">Uploading to server...</div>
        <button type="button" id="uploadCloseBtn" style="display: none; margin-top: 15px;" onclick="document.getElementById('uploadModal').classList.remove('active'); window.location.reload();">Close</button>
      </div>
    </div>

    <!-- Filter editor modal. -->
    <div id="filterEditorModal" class="filter-editor-modal">
      <div class="filter-editor-content">
        <div class="filter-editor-header">
          <div>
            <h2>Filter Editor</h2>
            <span id="filterEditorFilename" style="color: #aaa; font-size: 0.9em;"></span>
          </div>
          <button onclick="closeFilterEditor()" title="Close">&times;</button>
        </div>

        <div class="filter-editor-body">
          <canvas id="filterCanvas" width="600" height="448"></canvas>

          <div class="filter-controls">
            <label style="font-weight: bold;">Filter:</label>
            <div class="filter-buttons">
              <button data-filter="bicubic" class="active">Bicubic</button>
              <button data-filter="lanczos">Lanczos</button>
              <button data-filter="bilinear">Bilinear</button>
              <button data-filter="nearest">Nearest</button>
            </div>
            <div id="filterProcessing" class="processing-indicator"></div>
          </div>
        </div>

        <div class="filter-editor-footer">
          <button onclick="closeFilterEditor()">Cancel</button>
          <button onclick="applyFilterFromEditor()" class="button primary">Apply & Save</button>
        </div>
      </div>
    </div>

    <!-- Dither preview modal. -->
    <div id="ditherPreviewModal" class="filter-editor-modal">
      <div class="filter-editor-content">
        <div class="filter-editor-header">
          <div>
            <h2>Preview E-Ink Rendering</h2>
            <span id="ditherPreviewFilename" style="color: #aaa; font-size: 0.9em;"></span>
          </div>
          <button onclick="closeDitherPreview()" title="Close">&times;</button>
        </div>

        <div class="filter-editor-body">
          <div class="comparison-container">
            <div class="comparison-panel">
              <div class="comparison-label">Before (Resized)</div>
              <canvas id="ditherCanvasBefore" width="600" height="448"></canvas>
              <div class="comparison-dimensions">600 × 448</div>
            </div>
            <div class="comparison-panel">
              <div class="comparison-label">After (Dithered)</div>
              <canvas id="ditherCanvas" width="600" height="448"></canvas>
              <div class="comparison-dimensions">600 × 448 (7 colors)</div>
            </div>
          </div>

          <div class="filter-controls">
            <label style="font-weight: bold;">Saturation: <span id="saturationValue">0.5</span></label>
            <input type="range" id="saturationSlider" min="0.1" max="1.0" step="0.1" value="0.5"
                   style="width: 100%; margin: 10px 0;">

            <label style="display: block; margin-top: 15px;">
              <input type="checkbox" id="flashTwiceCheckbox" style="margin-right: 5px;">
              Flash twice (to overcome ghosting)
            </label>

            <div id="ditherProcessing" class="processing-indicator"></div>
          </div>
        </div>

        <div class="filter-editor-footer">
          <button onclick="closeDitherPreview()">Cancel</button>
          <button onclick="confirmFlash()" class="button primary">Flash to Display</button>
        </div>
      </div>
    </div>

    <script src="/js/filters.js"></script>
    <script src="/js/dither.js"></script>
    <script>
      const FLASH_DURATION_MS = 40000;

      // Image dimensions.
      const CACHE_WIDTH = 600;   // For preview/dithering (matches e-ink display).
      const CACHE_HEIGHT = 448;
      const THUMB_WIDTH = 150;   // For gallery thumbnails.
      const THUMB_HEIGHT = 112;

      let animationCancelled = false;
      let isFlashing = false;

      // Filter editor state.
      let filterWorker = null;
      let originalImageData = null;
      let editorCurrentFilter = 'bicubic';

      // Dither preview state.
      let ditherWorker = null;
      let ditherImageData = null;
      let ditherCurrentSaturation = 0.5;
      let ditherPendingFlash = null;

      // Upload cache generation state.
      let uploadCacheWorker = null;
      let uploadThumbWorker = null;
      let uploadImageData = null;
      let uploadCacheBlob = null;
      let uploadThumbBlob = null;
      let uploadCacheReady = false;
      let uploadThumbReady = false;
      let uploadXhrComplete = false;
      let uploadFilename = null;

      // Initialize upload cache worker (reuses filter worker).
      function initUploadCacheWorker() {
        if (uploadCacheWorker) return;

        uploadCacheWorker = new Worker('/js/filter-worker.js');
        uploadCacheWorker.onmessage = function(e) {
          if (e.data.success) {
            // Convert ImageData to PNG blob.
            const canvas = document.createElement('canvas');
            canvas.width = CACHE_WIDTH;
            canvas.height = CACHE_HEIGHT;
            const ctx = canvas.getContext('2d');
            ctx.putImageData(e.data.imageData, 0, 0);

            canvas.toBlob(function(blob) {
              uploadCacheBlob = blob;
              uploadCacheReady = true;
              console.log('Cache thumbnail generated, size:', blob.size);
              checkUploadComplete();
            }, 'image/png');
          } else {
            console.error('Cache generation failed:', e.data.error);
            // Mark as ready anyway so upload can complete (server repair will catch it).
            uploadCacheReady = true;
            uploadCacheBlob = null;
            checkUploadComplete();
          }
        };
      }

      // Initialize upload thumb worker (generates small gallery thumbnail).
      function initUploadThumbWorker() {
        if (uploadThumbWorker) return;

        uploadThumbWorker = new Worker('/js/filter-worker.js');
        uploadThumbWorker.onmessage = function(e) {
          if (e.data.success) {
            // Convert ImageData to PNG blob.
            const canvas = document.createElement('canvas');
            canvas.width = THUMB_WIDTH;
            canvas.height = THUMB_HEIGHT;
            const ctx = canvas.getContext('2d');
            ctx.putImageData(e.data.imageData, 0, 0);

            canvas.toBlob(function(blob) {
              uploadThumbBlob = blob;
              uploadThumbReady = true;
              console.log('Gallery thumbnail generated, size:', blob.size);
              checkUploadComplete();
            }, 'image/png');
          } else {
            console.error('Thumb generation failed:', e.data.error);
            uploadThumbReady = true;
            uploadThumbBlob = null;
            checkUploadComplete();
          }
        };
      }

      // Check if upload, cache, and thumb generation are complete.
      function checkUploadComplete() {
        if (!uploadCacheReady || !uploadThumbReady || !uploadXhrComplete) return;

        const noteEl = document.getElementById('uploadNote');
        noteEl.textContent = 'Saving thumbnails...';

        // Upload both cache and thumb in parallel.
        const uploads = [];

        if (uploadCacheBlob && uploadFilename) {
          const cacheForm = new FormData();
          cacheForm.append('filename', uploadFilename);
          cacheForm.append('file', uploadCacheBlob, uploadFilename + '.png');
          uploads.push(
            fetch('/api/upload-cache', { method: 'POST', body: cacheForm })
              .then(r => r.json())
              .then(data => {
                if (data.success) {
                  console.log('Cache uploaded:', data.path);
                } else {
                  console.error('Cache upload failed:', data.message);
                }
              })
              .catch(err => console.error('Cache upload error:', err))
          );
        }

        if (uploadThumbBlob && uploadFilename) {
          const thumbForm = new FormData();
          thumbForm.append('filename', uploadFilename);
          thumbForm.append('file', uploadThumbBlob, uploadFilename + '.png');
          uploads.push(
            fetch('/api/upload-thumb', { method: 'POST', body: thumbForm })
              .then(r => r.json())
              .then(data => {
                if (data.success) {
                  console.log('Thumb uploaded:', data.path);
                } else {
                  console.error('Thumb upload failed:', data.message);
                }
              })
              .catch(err => console.error('Thumb upload error:', err))
          );
        }

        // Wait for all uploads to complete.
        Promise.all(uploads).then(() => finishUpload(true));
      }

      // Finish upload and show completion UI.
      function finishUpload(success) {
        const titleEl = document.getElementById('uploadModalTitle');
        const noteEl = document.getElementById('uploadNote');
        const closeBtn = document.getElementById('uploadCloseBtn');
        const processingProgress = document.getElementById('processingProgress');

        processingProgress.style.width = '100%';
        processingProgress.classList.add('complete');

        if (success) {
          titleEl.textContent = '✓ Upload Complete!';
          titleEl.style.color = '#6B8E4E';
          noteEl.textContent = 'Image uploaded successfully.';
          noteEl.style.color = '#6B8E4E';
        } else {
          titleEl.textContent = '✗ Upload Failed';
          titleEl.style.color = '#ff4444';
          noteEl.textContent = 'Upload failed.';
          noteEl.style.color = '#ff4444';
        }
        closeBtn.style.display = 'inline-block';
      }

      // Initialize dither worker.
      function initDitherWorker() {
        if (ditherWorker) return;

        ditherWorker = new Worker('/js/dither-worker.js');
        ditherWorker.onmessage = function(e) {
          const processingEl = document.getElementById('ditherProcessing');

          if (e.data.success) {
            const canvas = document.getElementById('ditherCanvas');
            const ctx = canvas.getContext('2d');
            ctx.putImageData(e.data.imageData, 0, 0);
            processingEl.textContent = '';
          } else {
            processingEl.textContent = 'Error: ' + e.data.error;
            processingEl.style.color = '#ff4444';
          }
        };
      }

      // Show dither preview modal with the cached image.
      async function showDitherPreview(imagePath, filename) {
        initDitherWorker();

        // Store flash parameters for later.
        ditherPendingFlash = {
          imagePath: imagePath,
          filename: filename
        };

        // Load the cached image.
        const cachePath = imagePath.replace('images/', 'images/cache/') + '.png';

        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = function() {
          const canvas = document.getElementById('ditherCanvas');
          const ctx = canvas.getContext('2d');

          // Ensure canvas is 600x448.
          canvas.width = CACHE_WIDTH;
          canvas.height = CACHE_HEIGHT;

          // Draw image to canvas.
          ctx.drawImage(img, 0, 0, CACHE_WIDTH, CACHE_HEIGHT);

          // Also draw to the "before" canvas for comparison.
          const beforeCanvas = document.getElementById('ditherCanvasBefore');
          const beforeCtx = beforeCanvas.getContext('2d');
          beforeCanvas.width = CACHE_WIDTH;
          beforeCanvas.height = CACHE_HEIGHT;
          beforeCtx.drawImage(img, 0, 0, CACHE_WIDTH, CACHE_HEIGHT);

          // Get image data.
          ditherImageData = ctx.getImageData(0, 0, CACHE_WIDTH, CACHE_HEIGHT);

          // Reset saturation slider to default.
          const slider = document.getElementById('saturationSlider');
          slider.value = 0.5;
          document.getElementById('saturationValue').textContent = '0.5';
          ditherCurrentSaturation = 0.5;

          // Reset flash twice checkbox.
          document.getElementById('flashTwiceCheckbox').checked = false;

          // Perform initial dither.
          document.getElementById('ditherProcessing').textContent = 'Processing...';
          ditherWorker.postMessage({
            imageData: ditherImageData,
            saturation: ditherCurrentSaturation
          });

          // Show modal.
          document.getElementById('ditherPreviewFilename').textContent = filename;
          document.getElementById('ditherPreviewModal').classList.add('active');
        };

        img.onerror = function() {
          alert('Failed to load image: ' + cachePath);
        };

        img.src = '/' + cachePath;
      }

      // Close dither preview modal.
      function closeDitherPreview() {
        document.getElementById('ditherPreviewModal').classList.remove('active');
        ditherPendingFlash = null;
      }

      // Handle saturation slider change.
      document.addEventListener('DOMContentLoaded', function() {
        const slider = document.getElementById('saturationSlider');
        slider.addEventListener('input', function(e) {
          const saturation = parseFloat(e.target.value);
          document.getElementById('saturationValue').textContent = saturation;
          ditherCurrentSaturation = saturation;

          if (ditherImageData) {
            document.getElementById('ditherProcessing').textContent = 'Processing...';
            ditherWorker.postMessage({
              imageData: ditherImageData,
              saturation: saturation
            });
          }
        });
      });

      // Confirm flash - dither, upload, and flash.
      async function confirmFlash() {
        if (!ditherPendingFlash) {
          alert('No flash operation pending');
          return;
        }

        const { imagePath, filename } = ditherPendingFlash;

        // Get flash twice setting from modal checkbox.
        const flashTwice = document.getElementById('flashTwiceCheckbox').checked;

        // Close dither preview modal.
        closeDitherPreview();

        // Get the dithered canvas.
        const canvas = document.getElementById('ditherCanvas');

        // Convert canvas to blob.
        canvas.toBlob(async function(blob) {
          if (!blob) {
            alert('Failed to generate dithered image');
            return;
          }

          // Upload dithered image to server.
          const formData = new FormData();
          formData.append('filename', filename);
          formData.append('saturation', ditherCurrentSaturation);
          formData.append('file', blob, filename);

          try {
            const uploadResponse = await fetch('/api/upload-dithered', {
              method: 'POST',
              body: formData
            });

            if (!uploadResponse.ok) {
              alert('Failed to upload dithered image');
              return;
            }

            // Now proceed with flash.
            proceedWithFlash(imagePath, flashTwice, filename);

          } catch (error) {
            alert('Error uploading dithered image: ' + error.message);
          }
        }, 'image/png');
      }

      // Proceed with flash operation (after dithering and upload).
      function proceedWithFlash(imagePath, flashTwice, filename) {
        // Reset modal state.
        animationCancelled = false;
        document.getElementById('modalImage').src = imagePath;
        document.getElementById('modalFilename').textContent = filename;
        document.getElementById('progress1').style.width = '0%';
        document.getElementById('progress1').classList.remove('complete');
        document.getElementById('progress2').style.width = '0%';
        document.getElementById('progress2').classList.remove('complete');
        document.getElementById('flashNote').textContent = 'This takes about 40 seconds per flash...';
        document.getElementById('flashNote').style.color = '#666';
        document.getElementById('flashCloseBtn').style.display = 'none';
        document.querySelector('.flash-modal-content h2').textContent = 'Flashing to Display';
        document.querySelector('.flash-modal-content h2').style.color = '#B8956A';

        // Show/hide second progress bar.
        document.getElementById('progress2Container').style.display = flashTwice ? 'block' : 'none';

        // Update label if only one flash.
        document.querySelector('#progress1Container .progress-label').textContent =
          flashTwice ? 'Flash 1' : 'Flashing...';

        // Show modal.
        document.getElementById('flashModal').classList.add('active');

        // Start progress animation.
        if (flashTwice) {
          animateProgress('progress1', FLASH_DURATION_MS, function() {
            animateProgress('progress2', FLASH_DURATION_MS);
          });
        } else {
          animateProgress('progress1', FLASH_DURATION_MS);
        }

        // Submit via fetch.
        const formData = new FormData();
        formData.append('submission.image_file_path', imagePath);
        if (flashTwice) {
          formData.append('submission.flash_twice', 'yes');
        }

        fetch('/flash', {
          method: 'POST',
          body: formData
        })
        .then(response => {
          if (response.ok) {
            showFlashResult(true);
          } else {
            return response.text().then(text => {
              showFlashResult(false, 'Flash failed with status ' + response.status);
            });
          }
        })
        .catch(error => {
          showFlashResult(false, 'Network error: ' + error.message);
        });
      }

      // Initialize filter worker.
      function initFilterWorker() {
        if (filterWorker) return;

        filterWorker = new Worker('/js/filter-worker.js');
        filterWorker.onmessage = function(e) {
          const processingEl = document.getElementById('filterProcessing');

          if (e.data.success) {
            const canvas = document.getElementById('filterCanvas');
            const ctx = canvas.getContext('2d');
            ctx.putImageData(e.data.imageData, 0, 0);
            processingEl.textContent = '';
          } else {
            processingEl.textContent = 'Error: ' + e.data.error;
            processingEl.style.color = '#ff4444';
          }
        };
      }

      // Open filter editor for the currently selected image.
      function openFilterEditor() {
        if (!currentFilename) {
          alert('Please select an image first.');
          return;
        }

        initFilterWorker();

        const modal = document.getElementById('filterEditorModal');
        const filenameEl = document.getElementById('filterEditorFilename');
        const processingEl = document.getElementById('filterProcessing');

        filenameEl.textContent = currentFilename;
        processingEl.textContent = 'Loading original image...';
        processingEl.style.color = '#B8956A';

        // Set initial filter to saved preference.
        editorCurrentFilter = currentSavedFilter;
        document.querySelectorAll('.filter-buttons button').forEach(btn => {
          btn.classList.toggle('active', btn.dataset.filter === editorCurrentFilter);
        });

        modal.classList.add('active');

        // Load the original image (not the cached thumbnail).
        const img = new Image();
        img.onload = function() {
          // Draw full image to temporary canvas to get ImageData.
          const tempCanvas = document.createElement('canvas');
          tempCanvas.width = img.width;
          tempCanvas.height = img.height;
          const tempCtx = tempCanvas.getContext('2d');
          tempCtx.drawImage(img, 0, 0);
          originalImageData = tempCtx.getImageData(0, 0, img.width, img.height);

          processingEl.textContent = 'Resizing...';

          // Resize with current filter and display.
          applyFilterToCanvas(editorCurrentFilter);
        };
        img.onerror = function() {
          processingEl.textContent = 'Failed to load image.';
          processingEl.style.color = '#ff4444';
        };
        img.src = 'images/' + currentFilename;
      }

      // Close filter editor.
      function closeFilterEditor() {
        document.getElementById('filterEditorModal').classList.remove('active');
        originalImageData = null;
      }

      // Apply a filter to the canvas using the worker.
      function applyFilterToCanvas(filter) {
        if (!originalImageData) return;

        const processingEl = document.getElementById('filterProcessing');
        processingEl.textContent = 'Processing...';
        processingEl.style.color = '#B8956A';

        filterWorker.postMessage({
          imageData: originalImageData,
          width: CACHE_WIDTH,
          height: CACHE_HEIGHT,
          filter: filter
        });
      }

      // Handle filter button clicks.
      document.addEventListener('DOMContentLoaded', function() {
        document.querySelectorAll('.filter-buttons button').forEach(btn => {
          btn.addEventListener('click', function() {
            // Update active state.
            document.querySelectorAll('.filter-buttons button').forEach(b => {
              b.classList.remove('active');
            });
            this.classList.add('active');

            // Apply the filter.
            editorCurrentFilter = this.dataset.filter;
            applyFilterToCanvas(editorCurrentFilter);
          });
        });
      });

      // Apply filter from editor and save to server.
      function applyFilterFromEditor() {
        if (!currentFilename) return;

        const filterToSave = editorCurrentFilter;
        const processingEl = document.getElementById('filterProcessing');
        processingEl.textContent = 'Saving...';

        // Get the canvas with the already-computed filtered image (600x448).
        const canvas = document.getElementById('filterCanvas');

        // Generate both cache blob and thumb blob.
        canvas.toBlob(function(cacheBlob) {
          if (!cacheBlob) {
            processingEl.textContent = 'Error: Failed to generate image';
            processingEl.style.color = '#ff4444';
            return;
          }

          // Create smaller thumb from the same canvas.
          const thumbCanvas = document.createElement('canvas');
          thumbCanvas.width = THUMB_WIDTH;
          thumbCanvas.height = THUMB_HEIGHT;
          const thumbCtx = thumbCanvas.getContext('2d');
          thumbCtx.drawImage(canvas, 0, 0, THUMB_WIDTH, THUMB_HEIGHT);

          thumbCanvas.toBlob(function(thumbBlob) {
            // Upload both in parallel.
            const cacheForm = new FormData();
            cacheForm.append('filename', currentFilename);
            cacheForm.append('filter', filterToSave);
            cacheForm.append('file', cacheBlob, currentFilename + '.png');

            const thumbForm = new FormData();
            thumbForm.append('filename', currentFilename);
            thumbForm.append('file', thumbBlob, currentFilename + '.png');

            Promise.all([
              fetch('/api/upload-cache', { method: 'POST', body: cacheForm }).then(r => r.json()),
              fetch('/api/upload-thumb', { method: 'POST', body: thumbForm }).then(r => r.json())
            ])
            .then(([cacheData, thumbData]) => {
              if (cacheData.success && thumbData.success) {
                // Update saved filter.
                currentSavedFilter = filterToSave;

                // Update the thumbnail.
                const thumb = document.querySelector('img[data-filename="' + currentFilename + '"]');
                if (thumb) {
                  thumb.dataset.filter = filterToSave;
                  thumb.src = 'images/thumbs/' + currentFilename + '.png?t=' + Date.now();
                }

                // Update main filter dropdown.
                document.getElementById('filterSelect').value = filterToSave;

                // Close modal.
                closeFilterEditor();

                // Show success message.
                const statusEl = document.getElementById('filterStatus');
                statusEl.textContent = '✓ Filter saved';
                statusEl.style.color = '#6B8E4E';
              } else {
                processingEl.textContent = 'Error: Upload failed';
                processingEl.style.color = '#ff4444';
              }
            })
            .catch(err => {
              processingEl.textContent = 'Error: ' + err.message;
              processingEl.style.color = '#ff4444';
            });
          }, 'image/png');
        }, 'image/png');
      }

      // Currently selected image filename and its saved filter.
      let currentFilename = null;
      let currentSavedFilter = null;

      // Thumbnail selection helper.
      function selectThumbnail(el) {
        document.querySelectorAll('.thumbnails img').forEach(img => img.classList.remove('selected'));
        document.querySelectorAll('.thumbnail-placeholder').forEach(p => p.classList.remove('selected'));
        el.classList.add('selected');
        document.getElementById('submission.image_file_path').value = el.id;

        // Update current filename and filter dropdown.
        currentFilename = el.dataset.filename;
        currentSavedFilter = el.dataset.filter || 'bicubic';
        document.getElementById('filterSelect').value = currentSavedFilter;
        document.getElementById('filterStatus').textContent = '';

        // Show the cached image (full 600x448 resolution for accurate preview).
        document.getElementById('preview').src = 'images/cache/' + currentFilename + '.png';

        // Enable all image-dependent controls.
        document.getElementById('flashBtn').disabled = false;
        document.getElementById('filterSelect').disabled = false;
        document.getElementById('editFilterBtn').disabled = false;
      }

      // Placeholder selection helper (for uncached images - allows deletion).
      function selectPlaceholder(el) {
        document.querySelectorAll('.thumbnails img').forEach(img => img.classList.remove('selected'));
        document.querySelectorAll('.thumbnail-placeholder').forEach(p => p.classList.remove('selected'));
        el.classList.add('selected');
        document.getElementById('submission.image_file_path').value = el.id;

        // Update current filename.
        currentFilename = el.dataset.filename;
        currentSavedFilter = null;
        document.getElementById('filterStatus').textContent = '(no cache available)';

        // Clear preview since there's no cache.
        document.getElementById('preview').src = '';

        // Keep flash/filter buttons disabled (no cache to work with).
        document.getElementById('flashBtn').disabled = true;
        document.getElementById('filterSelect').disabled = true;
        document.getElementById('editFilterBtn').disabled = true;
      }

      // Poll for thumb status and replace placeholder when ready.
      // If thumb doesn't exist but cache does, generate thumb from cache.
      function pollThumbStatus(filename, path, placeholderEl) {
        fetch('/api/thumb-status/' + encodeURIComponent(filename))
          .then(r => r.json())
          .then(data => {
            if (data.ready) {
              // Thumb exists - show it.
              replacePlaceholderWithThumb(filename, path, placeholderEl, data.thumb_path);
            } else {
              // No thumb - try to generate from cache.
              generateThumbFromCache(filename, path, placeholderEl);
            }
          })
          .catch(err => {
            console.error('Thumb status poll failed:', err);
            setTimeout(() => pollThumbStatus(filename, path, placeholderEl), 2000);
          });
      }

      // Generate thumb from cache image.
      function generateThumbFromCache(filename, path, placeholderEl) {
        const cachePath = 'images/cache/' + filename + '.png';
        const img = new Image();
        img.crossOrigin = 'anonymous';

        img.onload = function() {
          // Resize to thumb dimensions.
          const canvas = document.createElement('canvas');
          canvas.width = THUMB_WIDTH;
          canvas.height = THUMB_HEIGHT;
          const ctx = canvas.getContext('2d');
          ctx.drawImage(img, 0, 0, THUMB_WIDTH, THUMB_HEIGHT);

          // Upload thumb.
          canvas.toBlob(function(blob) {
            const formData = new FormData();
            formData.append('filename', filename);
            formData.append('file', blob, filename + '.png');

            fetch('/api/upload-thumb', { method: 'POST', body: formData })
              .then(r => r.json())
              .then(data => {
                if (data.success) {
                  replacePlaceholderWithThumb(filename, path, placeholderEl, data.path);
                } else {
                  console.error('Thumb upload failed:', data.message);
                  setTimeout(() => pollThumbStatus(filename, path, placeholderEl), 5000);
                }
              })
              .catch(err => {
                console.error('Thumb upload error:', err);
                setTimeout(() => pollThumbStatus(filename, path, placeholderEl), 5000);
              });
          }, 'image/png');
        };

        img.onerror = function() {
          // Cache doesn't exist either - keep polling (upload may be in progress).
          setTimeout(() => pollThumbStatus(filename, path, placeholderEl), 1000);
        };

        img.src = cachePath;
      }

      // Replace placeholder with actual thumbnail image.
      function replacePlaceholderWithThumb(filename, path, placeholderEl, thumbPath) {
        const img = document.createElement('img');
        img.src = thumbPath;
        img.id = path;
        img.alt = path;
        img.dataset.filename = filename;
        img.dataset.filter = placeholderEl.dataset.filter || 'bicubic';
        img.onclick = function() { selectThumbnail(this); };
        placeholderEl.replaceWith(img);
      }

      // Start polling for any placeholders on page load.
      document.addEventListener('DOMContentLoaded', function() {
        document.querySelectorAll('.thumbnail-placeholder').forEach(el => {
          const filename = el.dataset.filename;
          const path = el.dataset.path;
          pollThumbStatus(filename, path, el);
        });
      });

      function animateProgress(elementId, durationMs, onComplete) {
        const el = document.getElementById(elementId);
        const startTime = Date.now();

        function update() {
          if (animationCancelled) return;

          const elapsed = Date.now() - startTime;
          const progress = Math.min(100, (elapsed / durationMs) * 100);
          el.style.width = progress + '%';

          if (progress < 100) {
            requestAnimationFrame(update);
          } else {
            el.classList.add('complete');
            if (onComplete) onComplete();
          }
        }
        requestAnimationFrame(update);
      }

      function completeAllProgress() {
        animationCancelled = true;
        const p1 = document.getElementById('progress1');
        const p2 = document.getElementById('progress2');
        p1.style.width = '100%';
        p1.classList.add('complete');
        if (document.getElementById('progress2Container').style.display !== 'none') {
          p2.style.width = '100%';
          p2.classList.add('complete');
        }
      }

      function showFlashResult(success, message) {
        completeAllProgress();
        const note = document.getElementById('flashNote');
        const closeBtn = document.getElementById('flashCloseBtn');
        const title = document.querySelector('.flash-modal-content h2');

        if (success) {
          title.textContent = '✓ Flash Complete!';
          title.style.color = '#6B8E4E';
          note.textContent = 'Image sent to display successfully.';
          note.style.color = '#6B8E4E';
        } else {
          title.textContent = '✗ Flash Failed';
          title.style.color = '#ff4444';
          note.textContent = message || 'An error occurred.';
          note.style.color = '#ff4444';
        }
        closeBtn.style.display = 'inline-block';
      }

      document.querySelector('form[action="/flash"]').addEventListener('submit', function(e) {
        // Check if delete button was clicked - if so, let form submit normally.
        if (e.submitter && e.submitter.formAction && e.submitter.formAction.endsWith('/delete')) {
          return;
        }

        e.preventDefault();

        const imagePath = document.getElementById('submission.image_file_path').value;
        if (!imagePath) {
          alert('Please select an image first.');
          return;
        }

        const filename = imagePath.split('/').pop();

        // Show dither preview modal (saturation and flash_twice are set in the modal).
        showDitherPreview(imagePath, filename);
      });

      // Upload functionality with real progress tracking.
      const uploadForm = document.getElementById('uploadForm');
      const fileInput = document.querySelector('input[name="submission.file"]');
      const uploadPreview = document.getElementById('uploadPreview');
      const uploadPreviewImg = document.getElementById('uploadPreviewImg');
      const uploadFileName = document.getElementById('uploadFileName');
      const uploadFileSize = document.getElementById('uploadFileSize');

      // Format bytes to human readable.
      function formatBytes(bytes) {
        if (bytes === 0) return '0 B';
        const k = 1024;
        const sizes = ['B', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
      }

      // Format seconds to mm:ss.
      function formatTime(seconds) {
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return mins + ':' + secs.toString().padStart(2, '0');
      }

      // Show preview when file is selected and prepare ImageData for cache generation.
      fileInput.addEventListener('change', function(e) {
        const file = e.target.files[0];
        const uploadBtn = document.getElementById('uploadBtn');
        if (file) {
          // Reset state.
          uploadImageData = null;
          uploadBtn.disabled = true;

          // Try to load as image (validates browser can actually render it).
          const objectUrl = URL.createObjectURL(file);
          const img = new Image();

          img.onload = function() {
            // Successfully loaded - prepare ImageData for cache generation.
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = img.width;
            tempCanvas.height = img.height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(img, 0, 0);
            uploadImageData = tempCtx.getImageData(0, 0, img.width, img.height);
            console.log('Prepared ImageData for cache generation:', img.width, 'x', img.height);

            uploadPreviewImg.src = objectUrl;
            uploadPreviewImg.style.display = 'block';
            uploadFileName.textContent = file.name;
            uploadFileSize.textContent = formatBytes(file.size);
            uploadPreview.classList.add('active');
            uploadBtn.disabled = false;
          };

          img.onerror = function() {
            // Failed to load - not a valid web image format.
            URL.revokeObjectURL(objectUrl);
            uploadPreviewImg.style.display = 'none';
            uploadFileName.textContent = file.name + ' (unsupported format)';
            uploadFileSize.textContent = 'Only JPEG, PNG, GIF, WebP supported';
            uploadPreview.classList.add('active');
            uploadBtn.disabled = true;
            console.error('Cannot load image:', file.name, file.type);
          };

          img.src = objectUrl;
        } else {
          uploadPreview.classList.remove('active');
          uploadBtn.disabled = true;
          uploadImageData = null;
        }
      });

      // Handle upload form submission.
      uploadForm.addEventListener('submit', function(e) {
        e.preventDefault();

        const file = fileInput.files[0];
        if (!file) {
          alert('Please select a file first.');
          return;
        }

        // Require valid image data (prevents uploading unsupported formats).
        if (!uploadImageData) {
          alert('Please select a valid image file (JPEG, PNG, GIF, or WebP).');
          return;
        }

        // Reset and show modal.
        const modal = document.getElementById('uploadModal');
        const modalImage = document.getElementById('uploadModalImage');
        const modalFilename = document.getElementById('uploadModalFilename');
        const progressBar = document.getElementById('uploadProgress');
        const percentEl = document.getElementById('uploadPercent');
        const speedEl = document.getElementById('uploadSpeed');
        const transferredEl = document.getElementById('uploadTransferred');
        const timeEl = document.getElementById('uploadTime');
        const noteEl = document.getElementById('uploadNote');
        const closeBtn = document.getElementById('uploadCloseBtn');
        const titleEl = document.getElementById('uploadModalTitle');

        const uploadProgressContainer = document.getElementById('uploadProgressContainer');
        const processingProgressContainer = document.getElementById('processingProgressContainer');
        const processingProgress = document.getElementById('processingProgress');

        // Set initial state.
        if (file.type.startsWith('image/')) {
          modalImage.src = URL.createObjectURL(file);
          modalImage.style.display = 'block';
        } else {
          modalImage.style.display = 'none';
        }
        modalFilename.textContent = file.name;
        progressBar.style.width = '0%';
        progressBar.classList.remove('complete');
        processingProgress.style.width = '0%';
        processingProgress.classList.remove('complete');
        uploadProgressContainer.style.display = 'block';
        processingProgressContainer.style.display = 'none';
        percentEl.textContent = '0%';
        speedEl.textContent = '-- MB/s';
        transferredEl.textContent = '0 / ' + formatBytes(file.size);
        timeEl.textContent = '0:00';
        noteEl.textContent = 'Uploading to server...';
        noteEl.style.color = '#666';
        closeBtn.style.display = 'none';
        titleEl.textContent = 'Uploading Image';
        titleEl.style.color = '#B8956A';

        modal.classList.add('active');
        let processingAnimationId = null;

        // Reset upload state.
        uploadCacheReady = false;
        uploadThumbReady = false;
        uploadXhrComplete = false;
        uploadCacheBlob = null;
        uploadThumbBlob = null;
        uploadFilename = file.name;

        // Start cache and thumb generation in parallel (if we have ImageData).
        if (uploadImageData) {
          initUploadCacheWorker();
          initUploadThumbWorker();
          console.log('Starting parallel cache/thumb generation for:', file.name);

          // Generate 600x448 cache for preview/dithering.
          uploadCacheWorker.postMessage({
            imageData: uploadImageData,
            width: CACHE_WIDTH,
            height: CACHE_HEIGHT,
            filter: 'bicubic'
          });

          // Generate gallery thumb.
          uploadThumbWorker.postMessage({
            imageData: uploadImageData,
            width: THUMB_WIDTH,
            height: THUMB_HEIGHT,
            filter: 'bicubic'
          });
        } else {
          // No ImageData (non-image file?), mark as ready to skip.
          uploadCacheReady = true;
          uploadThumbReady = true;
        }

        // Create XMLHttpRequest for progress tracking.
        const xhr = new XMLHttpRequest();
        const startTime = Date.now();
        let timerInterval;

        // Update elapsed time every second.
        timerInterval = setInterval(function() {
          const elapsed = (Date.now() - startTime) / 1000;
          timeEl.textContent = formatTime(elapsed);
        }, 1000);

        xhr.upload.addEventListener('progress', function(e) {
          if (e.lengthComputable) {
            const percent = Math.round((e.loaded / e.total) * 100);
            const elapsed = (Date.now() - startTime) / 1000;
            const speed = e.loaded / elapsed; // bytes per second

            progressBar.style.width = percent + '%';
            percentEl.textContent = percent + '%';
            transferredEl.textContent = formatBytes(e.loaded) + ' / ' + formatBytes(e.total);

            if (elapsed > 0.5) { // Wait a bit before showing speed to get stable reading.
              speedEl.textContent = formatBytes(speed) + '/s';
            }
          }
        });

        // When upload finishes, switch to processing state.
        xhr.upload.addEventListener('loadend', function() {
          progressBar.style.width = '100%';
          progressBar.classList.add('complete');
          percentEl.textContent = '100%';
          noteEl.textContent = 'Processing...';

          // Show processing progress bar and animate it.
          processingProgressContainer.style.display = 'block';
          const processingStartTime = Date.now();
          const estimatedProcessingMs = 3000; // Estimate ~3 seconds for processing.

          function animateProcessing() {
            const elapsed = Date.now() - processingStartTime;
            // Use asymptotic curve - gets slower as it approaches 95%.
            const progress = Math.min(95, (elapsed / estimatedProcessingMs) * 80 + (elapsed / (elapsed + 1000)) * 15);
            processingProgress.style.width = progress + '%';
            processingAnimationId = requestAnimationFrame(animateProcessing);
          }
          animateProcessing();
        });

        xhr.addEventListener('load', function() {
          clearInterval(timerInterval);
          if (processingAnimationId) cancelAnimationFrame(processingAnimationId);

          const elapsed = (Date.now() - startTime) / 1000;
          timeEl.textContent = formatTime(elapsed);

          // Complete upload progress bar.
          progressBar.style.width = '100%';
          progressBar.classList.add('complete');
          percentEl.textContent = '100%';

          if (xhr.status >= 200 && xhr.status < 300) {
            // Original upload succeeded, now wait for cache generation and upload.
            noteEl.textContent = 'Generating thumbnail...';
            uploadXhrComplete = true;
            checkUploadComplete();
          } else {
            // Upload failed, show error immediately.
            processingProgress.style.width = '100%';
            processingProgress.classList.add('complete');
            titleEl.textContent = '✗ Upload Failed';
            titleEl.style.color = '#ff4444';
            noteEl.textContent = 'Server returned status ' + xhr.status;
            noteEl.style.color = '#ff4444';
            closeBtn.style.display = 'inline-block';
          }
        });

        xhr.addEventListener('error', function() {
          clearInterval(timerInterval);
          if (processingAnimationId) cancelAnimationFrame(processingAnimationId);
          titleEl.textContent = '✗ Upload Failed';
          titleEl.style.color = '#ff4444';
          noteEl.textContent = 'Network error occurred.';
          noteEl.style.color = '#ff4444';
          closeBtn.style.display = 'inline-block';
        });

        xhr.addEventListener('abort', function() {
          clearInterval(timerInterval);
          if (processingAnimationId) cancelAnimationFrame(processingAnimationId);
          titleEl.textContent = '✗ Upload Cancelled';
          titleEl.style.color = '#ff4444';
          noteEl.textContent = 'Upload was cancelled.';
          noteEl.style.color = '#ff4444';
          closeBtn.style.display = 'inline-block';
        });

        // Build form data and send.
        const formData = new FormData();
        formData.append('submission.file', file);

        xhr.open('POST', '/upload');
        xhr.send(formData);
      });
    </script>
  </body>
</html>
